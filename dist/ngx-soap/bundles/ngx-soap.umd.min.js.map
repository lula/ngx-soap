{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://ngx-soap/lib/soap/nscontext.ts","ng://ngx-soap/lib/soap/utils.ts","ng://ngx-soap/lib/soap/wsdl.ts","ng://ngx-soap/lib/soap/security/BasicAuthSecurity.ts","ng://ngx-soap/lib/soap/security/WSSecurity.ts","ng://ngx-soap/lib/soap/security/BearerSecurity.ts","ng://ngx-soap/lib/soap/security/NTLMSecurity.ts","ng://ngx-soap/lib/soap/security/security.ts","ng://ngx-soap/lib/soap/client.ts","ng://ngx-soap/lib/soap/soap.ts","ng://ngx-soap/lib/ngx-soap.service.ts","ng://ngx-soap/lib/ngx-soap.module.ts"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","pop","length","push","NamespaceScope","parent","getNamespaceURI","prefix","localOnly","nsUri","namespaces","uri","getNamespaceMapping","declared","mapping","getPrefix","p","NamespaceContext","addNamespace","currentScope","pushContext","scope","scopes","popContext","registerNamespace","prefixCount","declareNamespace","findPrefix","xmlnsMapping","nsURI","utils.findPrefix","Primitives","string","boolean","decimal","float","double","anyType","byte","int","long","short","negativeInteger","nonNegativeInteger","positiveInteger","nonPositiveInteger","unsignedByte","unsignedInt","unsignedLong","unsignedShort","duration","dateTime","time","date","gYearMonth","gYear","gMonthDay","gDay","gMonth","hexBinary","base64Binary","anyURI","QName","NOTATION","splitQName","nsName","i","indexOf","name","substring","xmlEscape","obj","substr","replace","trimLeft","trimRight","trim","text","Element","attrs","options","parts","key","children","xmlns","_initializeOptions","match","exec","valueKey","undefined","$targetNamespace","prototype","xmlKey","ignoredNamespaces","deleteFixedAttrs","Object","keys","allowedChildren","startElement","stack","ChildClass","unexpected","endElement","parent_1","_.defaultsDeep","addChild","child","Error","description","definitions","$name","init","createSubClass","root","subElement","arguments","__proto__","ElementElement","AnyElement","InputElement","OutputElement","SimpleTypeElement","RestrictionElement","ExtensionElement","ChoiceElement","EnumerationElement","ComplexTypeElement","ComplexContentElement","SimpleContentElement","SequenceElement","AllElement","MessageElement","DocumentationElement","SchemaElement","TypesElement","OperationElement","PortTypeElement","BindingElement","PortElement","ServiceElement","DefinitionsElement","ElementTypeMap","types","schema","element","any","simpleType","restriction","extension","choice","enumeration","complexType","complexContent","simpleContent","sequence","all","service","port","binding","portType","message","operation","input","output","fault","documentation","mapElementTypes","rtn","split","forEach","type","complexTypes","elements","includes","schemas","inputSoap","outputSoap","style","soapAction","methods","transport","location","ports","messages","portTypes","bindings","services","merge","source","assert","_.merge","location_1","$schemaLocation","$location","namespace","$namespace","targetNamespace","hasOwnProperty","console","error","use","$use","encodingStyle","$encodingStyle","$soapAction","$style","$transport","postProcess","part","ns","$element","elementChildren","lookupTypes","targetNSAlias","$lookupType","_getNestedLookupTypeString","join","filter","schemaXmlns","_createLookupTypeObject","$lookupTypes","$type","typeNs","ctype","method","splice","schemaDefinition","nsString","splittedNSString","nsAlias","splittedName","lookupTypeObj","resolvedType","excluded","concat","self_1","resolvedChildType","tag","messageName","$message","$binding","desc","$base","typeName","schema_1","typeElement_1","getBase","map","typeElement","base","isMany","$maxOccurs","isNaN","$minOccurs","$ref","descriptions","elem_1","description_1","name_1","inputDesc","outputDesc","name_2","name_3","WSDL","definition","fromFunc","x","self","callback","_includesWsdl","WSDL_CACHE","charCodeAt","slice","_fromXML","_fromServices","processIncludes","name_4","name_5","bindingName","topEls","topElements","methodName","inputName","outputName","xmlnsInEnvelope","_xmlnsMap","catch","err","appendColon","charAt","noColonNameSpace","open_wsdl_recursive","fromCache","open_wsdl","wsdl_headers","wsdl_options","log","httpClient","get","responseType","toPromise","wsdlDef","_a","wsdl","onReady","BasicAuthSecurity","username","password","defaults","_username","_password","ignoreBaseNameSpaces","_originalIgnoredNamespaces","Array","isArray","override","escapeXML","returnFault","handleNilAsNull","namespaceArrayElements","request","forceSoap12Headers","customDeserializer","overrideRootElement","useEmptyTag","_processNextInclude","include","shift","test","includePath","url.resolve","_.assign","_.mergeWith","a","b","destination","_.isArray","describeServices","name_6","toXML","xml","xmlToObject","sax.parser","objectName","Envelope","Header","Security","UsernameToken","Username","Password","Body","Code","Value","Subcode","Reason","Text","statusCode","Detail","Fault","faultcode","faultstring","detail","id","object","refs","onopentag","node","attributeName","xsiTypeSchema","attributes","top","topSchema","elementAttributes","hasNonXmlnsAttribute","hasNilAttribute","originalName","isInput","onerror","href","hrefs","par","res","toLowerCase","attributesKey","xsiType","typeURI","typeDef","findSchemaObject","nil","onclosetag","cur","topObject","_.isPlainObject","oncdata","originalText","top_1","ontext","resume","parseInt","Date","preserveWhitespace","saxStream","sax.createStream","on","pipe","r","finish","write","close","ref","code","$value","info","qname","def","objectToDocumentXML","params","nsPrefix","_xml","args","parameterTypeObj","objectToXML","objectToRpcXML","isParts","defs","prefixedKey","isIgnoredNameSpace","filterOutIgnoredNameSpace","isFirst","xmlnsAttr","schemaObject","nsContext","parentNsPrefix","current","soapHeader","qualified","$elementFormDefault","prefixNamespace","xmlnsAttrib","xmlnsAttributes","attribute","item","arrayAttr","processAttributes","correctOuterNsPrefix","openingTagParts","attr","nonSubNameSpace","emptyNonSubNameSpace","nameWithNsRegex","childSchemaObject","findChildSchemaObject","childNsPrefix","childName","childNsURI","childXmlnsAttrib","elementQName","unqualified","$form","resolvedChildSchemaObject","typeQName","typePrefix","findSchemaType","$baseNameSpace","xsi_type","attrObj","attrKey","attrValue","backtrace","found","typeObj","typeInfo","baseQName","childNameSpace","foundBase","_parse","strict","str","alias","addHeaders","headers","Authorization","Buffer","toString","addOptions","validPasswordTypes","WSSecurity","_passwordType","passwordType","_hasTimeStamp","hasTimeStamp","hasNonce","_hasNonce","_hasTokenCreated","hasTokenCreated","actor","_actor","mustUnderstand","_mustUnderstand","BearerSecurity","token","_token","NTLMSecurity","domain","workstation","ntlm","getDate","d","pad","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","nonce","now","created","timeStampXml","getTime","Base64","stringify","sha1","Math","random","rawNonce","passwordDigest","Connection","security","nonIdentifierChars","Client","endpoint","events.EventEmitter","_initializeServices","promiseOptions","multiArgs","overridePromiseSuffix","suffix","util.inherits","addSoapHeader","soapHeaders","changeSoapHeader","index","getSoapHeaders","clearSoapHeaders","addHttpHeader","httpHeaders","getHttpHeaders","clearHttpHeaders","addBodyAttribute","bodyAttribute","bodyAttributes","composition_1","getOwnPropertyNames","prop","idx","array","getBodyAttributes","clearBodyAttributes","setEndpoint","describe","setSecurity","setSOAPAction","SOAPAction","_defineService","streamAllowed","stream","normalizeNames","envelopeKey","_definePort","_defineMethod","extraHeaders","_invoke","encoding","Content-Type","xmlnsSoap","header","lastIndexOf","assert.ok","lastMessage","lastRequest","lastEndpoint","exchangeId","uuid4","post","observe","response","lastResponse","lastResponseHeaders","json","_.isObject","JSON","parse","tryJSONparse","responseBody","html","term","parseSync","throwError","cache","getFromCache","url","wsdl.open_wsdl","_requestWSDL","disableCache","NgxSoapService","http","createClient","wsdlUrl","core","HttpClient","factory","Éµfac","providedIn","NgxSoapModule","imports","HttpClientModule"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","'use strict';\n\nexport class NamespaceScope {\n  parent: any;\n  namespaces: any;\n  constructor(parent: any) {\n    if (!(this instanceof NamespaceScope)) {\n      return new NamespaceScope(parent);\n    }\n    this.parent = parent;\n    this.namespaces = {};  \n  }\n\n  getNamespaceURI = function(prefix, localOnly) {\n    switch (prefix) {\n      case 'xml':\n        return 'http://www.w3.org/XML/1998/namespace';\n      case 'xmlns':\n        return 'http://www.w3.org/2000/xmlns/';\n      default:\n        var nsUri = this.namespaces[prefix];\n        /*jshint -W116 */\n        if (nsUri != null) {\n          return nsUri.uri;\n        } else if (!localOnly && this.parent) {\n          return this.parent.getNamespaceURI(prefix);\n        } else {\n          return null;\n        }\n    }\n  }\n\n  getNamespaceMapping = function(prefix) {\n    switch (prefix) {\n      case 'xml':\n        return {\n          uri: 'http://www.w3.org/XML/1998/namespace',\n          prefix: 'xml',\n          declared: true\n        };\n      case 'xmlns':\n        return {\n          uri: 'http://www.w3.org/2000/xmlns/',\n          prefix: 'xmlns',\n          declared: true\n        };\n      default:\n        var mapping = this.namespaces[prefix];\n        /*jshint -W116 */\n        if (mapping != null) {\n          return mapping;\n        } else if (this.parent) {\n          return this.parent.getNamespaceMapping(prefix);\n        } else {\n          return null;\n        }\n    }\n  }\n\n  getPrefix = function(nsUri, localOnly) {\n    switch (nsUri) {\n      case 'http://www.w3.org/XML/1998/namespace':\n        return 'xml';\n      case 'http://www.w3.org/2000/xmlns/':\n        return 'xmlns';\n      default:\n        for (var p in this.namespaces) {\n          if (this.namespaces[p].uri === nsUri) {\n            return p;\n          }\n        }\n        if (!localOnly && this.parent) {\n          return this.parent.getPrefix(nsUri);\n        } else {\n          return null;\n        }\n    }\n  }\n}\n\nexport class NamespaceContext {\n  scopes: any[];\n  prefixCount: number; \n\n  constructor() {\n    if (!(this instanceof NamespaceContext)) {\n      return new NamespaceContext();\n    }\n    this.scopes = [];\n    this.pushContext();\n    this.prefixCount = 0;\n  }\n\n  addNamespace = function(prefix, nsUri, localOnly) {\n    if (this.getNamespaceURI(prefix, localOnly) === nsUri) {\n      return false;\n    }\n    if (this.currentScope) {\n      this.currentScope.namespaces[prefix] = {\n        uri: nsUri,\n        prefix: prefix,\n        declared: false\n      };\n      return true;\n    }\n    return false;\n  }\n\n  pushContext = function() {\n    var scope = new NamespaceScope(this.currentScope);\n    this.scopes.push(scope);\n    this.currentScope = scope;\n    return scope;\n  }\n\n  popContext = function() {\n    var scope = this.scopes.pop();\n    if (scope) {\n      this.currentScope = scope.parent;\n    } else {\n      this.currentScope = null;\n    }\n    return scope;\n  }\n\n  getNamespaceURI = function(prefix, localOnly) {\n    return this.currentScope && this.currentScope.getNamespaceURI(prefix, localOnly);\n  }\n\n  getPrefix = function(nsUri, localOnly) {\n    return this.currentScope && this.currentScope.getPrefix(nsUri, localOnly);\n  }\n  \n  registerNamespace = function(nsUri) {\n    var prefix = this.getPrefix(nsUri);\n    if (prefix) {\n      // If the namespace has already mapped to a prefix\n      return prefix;\n    } else {\n      // Try to generate a unique namespace\n      while (true) {\n        prefix = 'ns' + (++this.prefixCount);\n        if (!this.getNamespaceURI(prefix)) {\n          // The prefix is not used\n          break;\n        }\n      }\n    }\n    this.addNamespace(prefix, nsUri, true);\n    return prefix;\n  }\n\n  declareNamespace = function(prefix, nsUri) {\n    if (this.currentScope) {\n      var mapping = this.currentScope.getNamespaceMapping(prefix);\n      if (mapping && mapping.uri === nsUri && mapping.declared) {\n        return false;\n      }\n      this.currentScope.namespaces[prefix] = {\n        uri: nsUri,\n        prefix: prefix,\n        declared: true\n      };\n      return true;\n    }\n    return false;\n  }\n}\n\n/**\n * Scope for XML namespaces\n * @param [parent] Parent scope\n * \n */\n// export function NamespaceScope(parent) {\n//   if (!(this instanceof NamespaceScope)) {\n//     return NamespaceScope(parent);\n//   }\n//   this.parent = parent;\n//   this.namespaces = {};\n// }\n\n// /**\n//  * Namespace context that manages hierarchical scopes\n//  *  {NamespaceContext}\n//  */\n// export function NamespaceContext() {\n//   if (!(this instanceof NamespaceContext)) {\n//     return NamespaceContext();\n//   }\n//   this.scopes = [];\n//   this.pushContext();\n//   this.prefixCount = 0;\n// }\n\n// /**\n//  * Look up the namespace URI by prefix\n//  * @param  prefix Namespace prefix\n//  * @param  [localOnly] Search current scope only\n//  *   Namespace URI\n//  */\n// NamespaceScope.prototype.getNamespaceURI = function(prefix, localOnly) {\n//   switch (prefix) {\n//     case 'xml':\n//       return 'http://www.w3.org/XML/1998/namespace';\n//     case 'xmlns':\n//       return 'http://www.w3.org/2000/xmlns/';\n//     default:\n//       var nsUri = this.namespaces[prefix];\n//       /*jshint -W116 */\n//       if (nsUri != null) {\n//         return nsUri.uri;\n//       } else if (!localOnly && this.parent) {\n//         return this.parent.getNamespaceURI(prefix);\n//       } else {\n//         return null;\n//       }\n//   }\n// };\n\n// NamespaceScope.prototype.getNamespaceMapping = function(prefix) {\n//   switch (prefix) {\n//     case 'xml':\n//       return {\n//         uri: 'http://www.w3.org/XML/1998/namespace',\n//         prefix: 'xml',\n//         declared: true\n//       };\n//     case 'xmlns':\n//       return {\n//         uri: 'http://www.w3.org/2000/xmlns/',\n//         prefix: 'xmlns',\n//         declared: true\n//       };\n//     default:\n//       var mapping = this.namespaces[prefix];\n//       /*jshint -W116 */\n//       if (mapping != null) {\n//         return mapping;\n//       } else if (this.parent) {\n//         return this.parent.getNamespaceMapping(prefix);\n//       } else {\n//         return null;\n//       }\n//   }\n// };\n\n// /**\n//  * Look up the namespace prefix by URI\n//  * @param  nsUri Namespace URI\n//  * @param  [localOnly] Search current scope only\n//  *   Namespace prefix\n//  */\n// NamespaceScope.prototype.getPrefix = function(nsUri, localOnly) {\n//   switch (nsUri) {\n//     case 'http://www.w3.org/XML/1998/namespace':\n//       return 'xml';\n//     case 'http://www.w3.org/2000/xmlns/':\n//       return 'xmlns';\n//     default:\n//       for (var p in this.namespaces) {\n//         if (this.namespaces[p].uri === nsUri) {\n//           return p;\n//         }\n//       }\n//       if (!localOnly && this.parent) {\n//         return this.parent.getPrefix(nsUri);\n//       } else {\n//         return null;\n//       }\n//   }\n// };\n\n// /**\n//  * Add a prefix/URI namespace mapping\n//  * @param  prefix Namespace prefix\n//  * @param  nsUri Namespace URI\n//  * @param  [localOnly] Search current scope only\n//  *  {boolean} true if the mapping is added or false if the mapping\n//  * already exists\n//  */\n// NamespaceContext.prototype.addNamespace = function(prefix, nsUri, localOnly) {\n//   if (this.getNamespaceURI(prefix, localOnly) === nsUri) {\n//     return false;\n//   }\n//   if (this.currentScope) {\n//     this.currentScope.namespaces[prefix] = {\n//       uri: nsUri,\n//       prefix: prefix,\n//       declared: false\n//     };\n//     return true;\n//   }\n//   return false;\n// };\n\n// /**\n//  * Push a scope into the context\n//  *  The current scope\n//  */\n// NamespaceContext.prototype.pushContext = function() {\n//   var scope = NamespaceScope(this.currentScope);\n//   this.scopes.push(scope);\n//   this.currentScope = scope;\n//   return scope;\n// };\n\n// /**\n//  * Pop a scope out of the context\n//  *   The removed scope\n//  */\n// NamespaceContext.prototype.popContext = function() {\n//   var scope = this.scopes.pop();\n//   if (scope) {\n//     this.currentScope = scope.parent;\n//   } else {\n//     this.currentScope = null;\n//   }\n//   return scope;\n// };\n\n// /**\n//  * Look up the namespace URI by prefix\n//  * @param  prefix Namespace prefix\n//  * @param  [localOnly] Search current scope only\n//  *   Namespace URI\n//  */\n// NamespaceContext.prototype.getNamespaceURI = function(prefix, localOnly) {\n//   return this.currentScope && this.currentScope.getNamespaceURI(prefix, localOnly);\n// };\n\n// /**\n//  * Look up the namespace prefix by URI\n//  * @param  nsURI Namespace URI\n//  * @param  [localOnly] Search current scope only\n//  *   Namespace prefix\n//  */\n// NamespaceContext.prototype.getPrefix = function(nsUri, localOnly) {\n//   return this.currentScope && this.currentScope.getPrefix(nsUri, localOnly);\n// };\n\n// /**\n//  * Register a namespace\n//  * @param  nsUri Namespace URI\n//  *   The matching or generated namespace prefix\n//  */\n// NamespaceContext.prototype.registerNamespace = function(nsUri) {\n//   var prefix = this.getPrefix(nsUri);\n//   if (prefix) {\n//     // If the namespace has already mapped to a prefix\n//     return prefix;\n//   } else {\n//     // Try to generate a unique namespace\n//     while (true) {\n//       prefix = 'ns' + (++this.prefixCount);\n//       if (!this.getNamespaceURI(prefix)) {\n//         // The prefix is not used\n//         break;\n//       }\n//     }\n//   }\n//   this.addNamespace(prefix, nsUri, true);\n//   return prefix;\n// };\n\n// /**\n//  * Declare a namespace prefix/uri mapping\n//  * @param  prefix Namespace prefix\n//  * @param  nsUri Namespace URI\n//  *   true if the declaration is created\n//  */\n// NamespaceContext.prototype.declareNamespace = function(prefix, nsUri) {\n//   if (this.currentScope) {\n//     var mapping = this.currentScope.getNamespaceMapping(prefix);\n//     if (mapping && mapping.uri === nsUri && mapping.declared) {\n//       return false;\n//     }\n//     this.currentScope.namespaces[prefix] = {\n//       uri: nsUri,\n//       prefix: prefix,\n//       declared: true\n//     };\n//     return true;\n//   }\n//   return false;\n// };\n","import sha1 from 'crypto-js/sha1';\nimport Base64 from 'crypto-js/enc-base64';\nimport { Buffer } from 'buffer';\n\nexport const passwordDigest = function passwordDigest(nonce, created, password) {\n  const rawNonce = new Buffer(nonce || '', 'base64').toString('binary');\n  return Base64.stringify(sha1(rawNonce + created + password, ''));\n};\n\nexport const TNS_PREFIX = '__tns__'; // Prefix for targetNamespace\n\n/**\n * Find a key from an object based on the value\n * @param  Namespace prefix/uri mapping\n * @param  nsURI value\n * @returns  The matching key\n */\nexport const findPrefix = function(xmlnsMapping, nsURI) {\n  for (const n in xmlnsMapping) {\n    if (n === TNS_PREFIX) { continue; }\n    if (xmlnsMapping[n] === nsURI) {\n      return n;\n    }\n  }\n};\n","/*\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\n * MIT Licensed\n *\n */\n/*jshint proto:true*/\n\n\"use strict\";\n\nimport * as sax from 'sax';\nimport { HttpClient } from '@angular/common/http';\nimport { NamespaceContext } ÃÂ from './nscontext';\n\nimport * as url from 'url';\nimport { ok as assert } from 'assert';\n// import stripBom from 'strip-bom';\n\nconst stripBom = (x: string): string => {\n  // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n  // conversion translates it to FEFF (UTF-16 BOM)\n  if (x.charCodeAt(0) === 0xFEFF) {\n    return x.slice(1);\n  }\n\n  return x;\n}\n\nimport * as _ from 'lodash';\nimport * as utils from './utils';\n\n\nlet TNS_PREFIX = utils.TNS_PREFIX;\nlet findPrefix = utils.findPrefix;\n\nlet Primitives = {\n  string: 1,\n  boolean: 1,\n  decimal: 1,\n  float: 1,\n  double: 1,\n  anyType: 1,\n  byte: 1,\n  int: 1,\n  long: 1,\n  short: 1,\n  negativeInteger: 1,\n  nonNegativeInteger: 1,\n  positiveInteger: 1,\n  nonPositiveInteger: 1,\n  unsignedByte: 1,\n  unsignedInt: 1,\n  unsignedLong: 1,\n  unsignedShort: 1,\n  duration: 0,\n  dateTime: 0,\n  time: 0,\n  date: 0,\n  gYearMonth: 0,\n  gYear: 0,\n  gMonthDay: 0,\n  gDay: 0,\n  gMonth: 0,\n  hexBinary: 0,\n  base64Binary: 0,\n  anyURI: 0,\n  QName: 0,\n  NOTATION: 0\n};\n\nfunction splitQName(nsName) {\n  let i = typeof nsName === 'string' ? nsName.indexOf(':') : -1;\n  return i < 0 ? { prefix: TNS_PREFIX, name: nsName } :\n    { prefix: nsName.substring(0, i), name: nsName.substring(i + 1) };\n}\n\nfunction xmlEscape(obj) {\n  if (typeof (obj) === 'string') {\n    if (obj.substr(0, 9) === '<![CDATA[' && obj.substr(-3) === \"]]>\") {\n      return obj;\n    }\n    return obj\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&apos;');\n  }\n\n  return obj;\n}\n\nlet trimLeft = /^[\\s\\xA0]+/;\nlet trimRight = /[\\s\\xA0]+$/;\n\nfunction trim(text) {\n  return text.replace(trimLeft, '').replace(trimRight, '');\n}\n\nfunction deepMerge(destination, source) {\n  return _.mergeWith(destination || {}, source, function (a, b) {\n    return _.isArray(a) ? a.concat(b) : undefined;\n  });\n}\n\nlet Element: any = function (nsName, attrs, options) {\n  let parts = splitQName(nsName);\n\n  this.nsName = nsName;\n  this.prefix = parts.prefix;\n  this.name = parts.name;\n  this.children = [];\n  this.xmlns = {};\n\n  this._initializeOptions(options);\n\n  for (let key in attrs) {\n    let match = /^xmlns:?(.*)$/.exec(key);\n    if (match) {\n      this.xmlns[match[1] ? match[1] : TNS_PREFIX] = attrs[key];\n    }\n    else {\n      if (key === 'value') {\n        this[this.valueKey] = attrs[key];\n      } else {\n        this['$' + key] = attrs[key];\n      }\n    }\n  }\n  if (this.$targetNamespace !== undefined) {\n    // Add targetNamespace to the mapping\n    this.xmlns[TNS_PREFIX] = this.$targetNamespace;\n  }\n};\n\nElement.prototype._initializeOptions = function (options) {\n  if (options) {\n    this.valueKey = options.valueKey || '$value';\n    this.xmlKey = options.xmlKey || '$xml';\n    this.ignoredNamespaces = options.ignoredNamespaces || [];\n  } else {\n    this.valueKey = '$value';\n    this.xmlKey = '$xml';\n    this.ignoredNamespaces = [];\n  }\n};\n\nElement.prototype.deleteFixedAttrs = function () {\n  this.children && this.children.length === 0 && delete this.children;\n  this.xmlns && Object.keys(this.xmlns).length === 0 && delete this.xmlns;\n  delete this.nsName;\n  delete this.prefix;\n  delete this.name;\n};\n\nElement.prototype.allowedChildren = [];\n\nElement.prototype.startElement = function (stack, nsName, attrs, options) {\n  if (!this.allowedChildren) {\n    return;\n  }\n\n  let ChildClass = this.allowedChildren[splitQName(nsName).name],\n    element = null;\n\n  if (ChildClass) {\n    stack.push(new ChildClass(nsName, attrs, options));\n  }\n  else {\n    this.unexpected(nsName);\n  }\n\n};\n\nElement.prototype.endElement = function (stack, nsName) {\n  if (this.nsName === nsName) {\n    if (stack.length < 2)\n      return;\n    let parent = stack[stack.length - 2];\n    if (this !== stack[0]) {\n      _.defaultsDeep(stack[0].xmlns, this.xmlns);\n      // delete this.xmlns;\n      parent.children.push(this);\n      parent.addChild(this);\n    }\n    stack.pop();\n  }\n};\n\nElement.prototype.addChild = function (child) {\n  return;\n};\n\nElement.prototype.unexpected = function (name) {\n  throw new Error('Found unexpected element (' + name + ') inside ' + this.nsName);\n};\n\nElement.prototype.description = function (definitions) {\n  return this.$name || this.name;\n};\n\nElement.prototype.init = function () {\n};\n\nElement.createSubClass = function () {\n  let root = this;\n  let subElement = function () {\n    root.apply(this, arguments);\n    this.init();\n  };\n  // inherits(subElement, root);\n  subElement.prototype.__proto__ = root.prototype;\n  return subElement;\n};\n\n\nlet ElementElement = Element.createSubClass();\nlet AnyElement = Element.createSubClass();\nlet InputElement = Element.createSubClass();\nlet OutputElement = Element.createSubClass();\nlet SimpleTypeElement = Element.createSubClass();\nlet RestrictionElement = Element.createSubClass();\nlet ExtensionElement = Element.createSubClass();\nlet ChoiceElement = Element.createSubClass();\nlet EnumerationElement = Element.createSubClass();\nlet ComplexTypeElement = Element.createSubClass();\nlet ComplexContentElement = Element.createSubClass();\nlet SimpleContentElement = Element.createSubClass();\nlet SequenceElement = Element.createSubClass();\nlet AllElement = Element.createSubClass();\nlet MessageElement = Element.createSubClass();\nlet DocumentationElement = Element.createSubClass();\n\nlet SchemaElement = Element.createSubClass();\nlet TypesElement = Element.createSubClass();\nlet OperationElement = Element.createSubClass();\nlet PortTypeElement = Element.createSubClass();\nlet BindingElement = Element.createSubClass();\nlet PortElement = Element.createSubClass();\nlet ServiceElement = Element.createSubClass();\nlet DefinitionsElement = Element.createSubClass();\n\nlet ElementTypeMap = {\n  types: [TypesElement, 'schema documentation'],\n  schema: [SchemaElement, 'element complexType simpleType include import'],\n  element: [ElementElement, 'annotation complexType'],\n  any: [AnyElement, ''],\n  simpleType: [SimpleTypeElement, 'restriction'],\n  restriction: [RestrictionElement, 'enumeration all choice sequence'],\n  extension: [ExtensionElement, 'all sequence choice'],\n  choice: [ChoiceElement, 'element sequence choice any'],\n  // group: [GroupElement, 'element group'],\n  enumeration: [EnumerationElement, ''],\n  complexType: [ComplexTypeElement, 'annotation sequence all complexContent simpleContent choice'],\n  complexContent: [ComplexContentElement, 'extension'],\n  simpleContent: [SimpleContentElement, 'extension'],\n  sequence: [SequenceElement, 'element sequence choice any'],\n  all: [AllElement, 'element choice'],\n\n  service: [ServiceElement, 'port documentation'],\n  port: [PortElement, 'address documentation'],\n  binding: [BindingElement, '_binding SecuritySpec operation documentation'],\n  portType: [PortTypeElement, 'operation documentation'],\n  message: [MessageElement, 'part documentation'],\n  operation: [OperationElement, 'documentation input output fault _operation'],\n  input: [InputElement, 'body SecuritySpecRef documentation header'],\n  output: [OutputElement, 'body SecuritySpecRef documentation header'],\n  fault: [Element, '_fault documentation'],\n  definitions: [DefinitionsElement, 'types message portType binding service import documentation'],\n  documentation: [DocumentationElement, '']\n};\n\nfunction mapElementTypes(types) {\n  let rtn = {};\n  types = types.split(' ');\n  types.forEach(function (type) {\n    rtn[type.replace(/^_/, '')] = (ElementTypeMap[type] || [Element])[0];\n  });\n  return rtn;\n}\n\nfor (let n in ElementTypeMap) {\n  let v = ElementTypeMap[n];\n  v[0].prototype.allowedChildren = mapElementTypes(v[1]);\n}\n\nMessageElement.prototype.init = function () {\n  this.element = null;\n  this.parts = null;\n};\n\nSchemaElement.prototype.init = function () {\n  this.complexTypes = {};\n  this.types = {};\n  this.elements = {};\n  this.includes = [];\n};\n\nTypesElement.prototype.init = function () {\n  this.schemas = {};\n};\n\nOperationElement.prototype.init = function () {\n  this.input = null;\n  this.output = null;\n  this.inputSoap = null;\n  this.outputSoap = null;\n  this.style = '';\n  this.soapAction = '';\n};\n\nPortTypeElement.prototype.init = function () {\n  this.methods = {};\n};\n\nBindingElement.prototype.init = function () {\n  this.transport = '';\n  this.style = '';\n  this.methods = {};\n};\n\nPortElement.prototype.init = function () {\n  this.location = null;\n};\n\nServiceElement.prototype.init = function () {\n  this.ports = {};\n};\n\nDefinitionsElement.prototype.init = function () {\n  if (this.name !== 'definitions') this.unexpected(this.nsName);\n  this.messages = {};\n  this.portTypes = {};\n  this.bindings = {};\n  this.services = {};\n  this.schemas = {};\n};\n\nDocumentationElement.prototype.init = function () {\n};\n\nSchemaElement.prototype.merge = function (source) {\n  assert(source instanceof SchemaElement);\n  if (this.$targetNamespace === source.$targetNamespace) {\n    _.merge(this.complexTypes, source.complexTypes);\n    _.merge(this.types, source.types);\n    _.merge(this.elements, source.elements);\n    _.merge(this.xmlns, source.xmlns);\n  }\n  return this;\n};\n\n\nSchemaElement.prototype.addChild = function (child) {\n  if (child.$name in Primitives)\n    return;\n  if (child.name === 'include' || child.name === 'import') {\n    let location = child.$schemaLocation || child.$location;\n    if (location) {\n      this.includes.push({\n        namespace: child.$namespace || child.$targetNamespace || this.$targetNamespace,\n        location: location\n      });\n    }\n  }\n  else if (child.name === 'complexType') {\n    this.complexTypes[child.$name] = child;\n  }\n  else if (child.name === 'element') {\n    this.elements[child.$name] = child;\n  }\n  else if (child.$name) {\n    this.types[child.$name] = child;\n  }\n  this.children.pop();\n  // child.deleteFixedAttrs();\n};\n//fix#325\nTypesElement.prototype.addChild = function (child) {\n  assert(child instanceof SchemaElement);\n\n  let targetNamespace = child.$targetNamespace;\n\n  if (!this.schemas.hasOwnProperty(targetNamespace)) {\n    this.schemas[targetNamespace] = child;\n  } else {\n    console.error('Target-Namespace \"' + targetNamespace + '\" already in use by another Schema!');\n  }\n};\n\nInputElement.prototype.addChild = function (child) {\n  if (child.name === 'body') {\n    this.use = child.$use;\n    if (this.use === 'encoded') {\n      this.encodingStyle = child.$encodingStyle;\n    }\n    this.children.pop();\n  }\n};\n\nOutputElement.prototype.addChild = function (child) {\n  if (child.name === 'body') {\n    this.use = child.$use;\n    if (this.use === 'encoded') {\n      this.encodingStyle = child.$encodingStyle;\n    }\n    this.children.pop();\n  }\n};\n\nOperationElement.prototype.addChild = function (child) {\n  if (child.name === 'operation') {\n    this.soapAction = child.$soapAction || '';\n    this.style = child.$style || '';\n    this.children.pop();\n  }\n};\n\nBindingElement.prototype.addChild = function (child) {\n  if (child.name === 'binding') {\n    this.transport = child.$transport;\n    this.style = child.$style;\n    this.children.pop();\n  }\n};\n\nPortElement.prototype.addChild = function (child) {\n  if (child.name === 'address' && typeof (child.$location) !== 'undefined') {\n    this.location = child.$location;\n  }\n};\n\nDefinitionsElement.prototype.addChild = function (child) {\n  let self = this;\n  if (child instanceof TypesElement) {\n    // Merge types.schemas into definitions.schemas\n    _.merge(self.schemas, child.schemas);\n  }\n  else if (child instanceof MessageElement) {\n    self.messages[child.$name] = child;\n  }\n  else if (child.name === 'import') {\n    self.schemas[child.$namespace] = new SchemaElement(child.$namespace, {});\n    self.schemas[child.$namespace].addChild(child);\n  }\n  else if (child instanceof PortTypeElement) {\n    self.portTypes[child.$name] = child;\n  }\n  else if (child instanceof BindingElement) {\n    if (child.transport === 'http://schemas.xmlsoap.org/soap/http' ||\n      child.transport === 'http://www.w3.org/2003/05/soap/bindings/HTTP/')\n      self.bindings[child.$name] = child;\n  }\n  else if (child instanceof ServiceElement) {\n    self.services[child.$name] = child;\n  }\n  else if (child instanceof DocumentationElement) {\n  }\n  this.children.pop();\n};\n\nMessageElement.prototype.postProcess = function (definitions) {\n  let part = null;\n  let child = undefined;\n  let children = this.children || [];\n  let ns = undefined;\n  let nsName = undefined;\n  let i = undefined;\n  let type = undefined;\n\n  for (i in children) {\n    if ((child = children[i]).name === 'part') {\n      part = child;\n      break;\n    }\n  }\n\n  if (!part) {\n    return;\n  }\n\n  if (part.$element) {\n    let lookupTypes = [],\n      elementChildren;\n\n    delete this.parts;\n\n    nsName = splitQName(part.$element);\n    ns = nsName.prefix;\n    let schema = definitions.schemas[definitions.xmlns[ns]];\n    this.element = schema.elements[nsName.name];\n    if (!this.element) {\n      // debug(nsName.name + \" is not present in wsdl and cannot be processed correctly.\");\n      return;\n    }\n    this.element.targetNSAlias = ns;\n    this.element.targetNamespace = definitions.xmlns[ns];\n\n    // set the optional $lookupType to be used within `client#_invoke()` when\n    // calling `wsdl#objectToDocumentXML()\n    this.element.$lookupType = part.$element;\n\n    elementChildren = this.element.children;\n\n    // get all nested lookup types (only complex types are followed)\n    if (elementChildren.length > 0) {\n      for (i = 0; i < elementChildren.length; i++) {\n        lookupTypes.push(this._getNestedLookupTypeString(elementChildren[i]));\n      }\n    }\n\n    // if nested lookup types where found, prepare them for furter usage\n    if (lookupTypes.length > 0) {\n      lookupTypes = lookupTypes.\n        join('_').\n        split('_').\n        filter(function removeEmptyLookupTypes(type) {\n          return type !== '^';\n        });\n\n      let schemaXmlns = definitions.schemas[this.element.targetNamespace].xmlns;\n\n      for (i = 0; i < lookupTypes.length; i++) {\n        lookupTypes[i] = this._createLookupTypeObject(lookupTypes[i], schemaXmlns);\n      }\n    }\n\n    this.element.$lookupTypes = lookupTypes;\n\n    if (this.element.$type) {\n      type = splitQName(this.element.$type);\n      let typeNs = schema.xmlns && schema.xmlns[type.prefix] || definitions.xmlns[type.prefix];\n\n      if (typeNs) {\n        if (type.name in Primitives) {\n          // this.element = this.element.$type;\n        }\n        else {\n          // first check local mapping of ns alias to namespace\n          schema = definitions.schemas[typeNs];\n          let ctype = schema.complexTypes[type.name] || schema.types[type.name] || schema.elements[type.name];\n\n\n          if (ctype) {\n            this.parts = ctype.description(definitions, schema.xmlns);\n          }\n        }\n      }\n    }\n    else {\n      let method = this.element.description(definitions, schema.xmlns);\n      this.parts = method[nsName.name];\n    }\n\n\n    this.children.splice(0, 1);\n  } else {\n    // rpc encoding\n    this.parts = {};\n    delete this.element;\n    for (i = 0; part = this.children[i]; i++) {\n      if (part.name === 'documentation') {\n        // <wsdl:documentation can be present under <wsdl:message>\n        continue;\n      }\n      assert(part.name === 'part', 'Expected part element');\n      nsName = splitQName(part.$type);\n      ns = definitions.xmlns[nsName.prefix];\n      type = nsName.name;\n      let schemaDefinition = definitions.schemas[ns];\n      if (typeof schemaDefinition !== 'undefined') {\n        this.parts[part.$name] = definitions.schemas[ns].types[type] || definitions.schemas[ns].complexTypes[type];\n      } else {\n        this.parts[part.$name] = part.$type;\n      }\n\n      if (typeof this.parts[part.$name] === 'object') {\n        this.parts[part.$name].prefix = nsName.prefix;\n        this.parts[part.$name].xmlns = ns;\n      }\n\n      this.children.splice(i--, 1);\n    }\n  }\n  this.deleteFixedAttrs();\n};\n\n/**\n * Takes a given namespaced String(for example: 'alias:property') and creates a lookupType\n * object for further use in as first (lookup) `parameterTypeObj` within the `objectToXML`\n * method and provides an entry point for the already existing code in `findChildSchemaObject`.\n *\n * @method _createLookupTypeObject\n * @param {String}            nsString          The NS String (for example \"alias:type\").\n * @param {Object}            xmlns       The fully parsed `wsdl` definitions object (including all schemas).\n * @returns {Object}\n * @private\n */\nMessageElement.prototype._createLookupTypeObject = function (nsString, xmlns) {\n  let splittedNSString = splitQName(nsString),\n    nsAlias = splittedNSString.prefix,\n    splittedName = splittedNSString.name.split('#'),\n    type = splittedName[0],\n    name = splittedName[1],\n    lookupTypeObj: any = {};\n\n  lookupTypeObj.$namespace = xmlns[nsAlias];\n  lookupTypeObj.$type = nsAlias + ':' + type;\n  lookupTypeObj.$name = name;\n\n  return lookupTypeObj;\n};\n\n/**\n * Iterates through the element and every nested child to find any defined `$type`\n * property and returns it in a underscore ('_') separated String (using '^' as default\n * value if no `$type` property was found).\n *\n * @method _getNestedLookupTypeString\n * @param {Object}            element         The element which (probably) contains nested `$type` values.\n * @returns {String}\n * @private\n */\nMessageElement.prototype._getNestedLookupTypeString = function (element) {\n  let resolvedType = '^',\n    excluded = this.ignoredNamespaces.concat('xs'); // do not process $type values wich start with\n\n  if (element.hasOwnProperty('$type') && typeof element.$type === 'string') {\n    if (excluded.indexOf(element.$type.split(':')[0]) === -1) {\n      resolvedType += ('_' + element.$type + '#' + element.$name);\n    }\n  }\n\n  if (element.children.length > 0) {\n    let self = this;\n\n    element.children.forEach(function (child) {\n      let resolvedChildType = self._getNestedLookupTypeString(child).replace(/\\^_/, '');\n\n      if (resolvedChildType && typeof resolvedChildType === 'string') {\n        resolvedType += ('_' + resolvedChildType);\n      }\n    });\n  }\n\n  return resolvedType;\n};\n\nOperationElement.prototype.postProcess = function (definitions, tag) {\n  let children = this.children;\n  for (let i = 0, child; child = children[i]; i++) {\n    if (child.name !== 'input' && child.name !== 'output')\n      continue;\n    if (tag === 'binding') {\n      this[child.name] = child;\n      children.splice(i--, 1);\n      continue;\n    }\n    let messageName = splitQName(child.$message).name;\n    let message = definitions.messages[messageName];\n    message.postProcess(definitions);\n    if (message.element) {\n      definitions.messages[message.element.$name] = message;\n      this[child.name] = message.element;\n    }\n    else {\n      this[child.name] = message;\n    }\n    children.splice(i--, 1);\n  }\n  this.deleteFixedAttrs();\n};\n\nPortTypeElement.prototype.postProcess = function (definitions) {\n  let children = this.children;\n  if (typeof children === 'undefined')\n    return;\n  for (let i = 0, child; child = children[i]; i++) {\n    if (child.name !== 'operation')\n      continue;\n    child.postProcess(definitions, 'portType');\n    this.methods[child.$name] = child;\n    children.splice(i--, 1);\n  }\n  delete this.$name;\n  this.deleteFixedAttrs();\n};\n\nBindingElement.prototype.postProcess = function (definitions) {\n  let type = splitQName(this.$type).name,\n    portType = definitions.portTypes[type],\n    style = this.style,\n    children = this.children;\n  if (portType) {\n    portType.postProcess(definitions);\n    this.methods = portType.methods;\n\n    for (let i = 0, child; child = children[i]; i++) {\n      if (child.name !== 'operation')\n        continue;\n      child.postProcess(definitions, 'binding');\n      children.splice(i--, 1);\n      child.style || (child.style = style);\n      let method = this.methods[child.$name];\n\n      if (method) {\n        method.style = child.style;\n        method.soapAction = child.soapAction;\n        method.inputSoap = child.input || null;\n        method.outputSoap = child.output || null;\n        method.inputSoap && method.inputSoap.deleteFixedAttrs();\n        method.outputSoap && method.outputSoap.deleteFixedAttrs();\n      }\n    }\n  }\n  delete this.$name;\n  delete this.$type;\n  this.deleteFixedAttrs();\n};\n\nServiceElement.prototype.postProcess = function (definitions) {\n  let children = this.children,\n    bindings = definitions.bindings;\n  if (children && children.length > 0) {\n    for (let i = 0, child; child = children[i]; i++) {\n      if (child.name !== 'port')\n        continue;\n      let bindingName = splitQName(child.$binding).name;\n      let binding = bindings[bindingName];\n      if (binding) {\n        binding.postProcess(definitions);\n        this.ports[child.$name] = {\n          location: child.location,\n          binding: binding\n        };\n        children.splice(i--, 1);\n      }\n    }\n  }\n  delete this.$name;\n  this.deleteFixedAttrs();\n};\n\n\nSimpleTypeElement.prototype.description = function (definitions) {\n  let children = this.children;\n  for (let i = 0, child; child = children[i]; i++) {\n    if (child instanceof RestrictionElement)\n      return this.$name + \"|\" + child.description();\n  }\n  return {};\n};\n\nRestrictionElement.prototype.description = function (definitions, xmlns) {\n  let children = this.children;\n  let desc;\n  for (let i = 0, child; child = children[i]; i++) {\n    if (child instanceof SequenceElement ||\n      child instanceof ChoiceElement) {\n      desc = child.description(definitions, xmlns);\n      break;\n    }\n  }\n  if (desc && this.$base) {\n    let type = splitQName(this.$base),\n      typeName = type.name,\n      ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix],\n      schema = definitions.schemas[ns],\n      typeElement = schema && (schema.complexTypes[typeName] || schema.types[typeName] || schema.elements[typeName]);\n\n    desc.getBase = function () {\n      return typeElement.description(definitions, schema.xmlns);\n    };\n    return desc;\n  }\n\n  // then simple element\n  let base = this.$base ? this.$base + \"|\" : \"\";\n  return base + this.children.map(function (child) {\n    return child.description();\n  }).join(\",\");\n};\n\nExtensionElement.prototype.description = function (definitions, xmlns) {\n  let children = this.children;\n  let desc = {};\n  for (let i = 0, child; child = children[i]; i++) {\n    if (child instanceof SequenceElement ||\n      child instanceof ChoiceElement) {\n      desc = child.description(definitions, xmlns);\n    }\n  }\n  if (this.$base) {\n    let type = splitQName(this.$base),\n      typeName = type.name,\n      ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix],\n      schema = definitions.schemas[ns];\n\n    if (typeName in Primitives) {\n      return this.$base;\n    }\n    else {\n      let typeElement = schema && (schema.complexTypes[typeName] ||\n        schema.types[typeName] || schema.elements[typeName]);\n\n      if (typeElement) {\n        let base = typeElement.description(definitions, schema.xmlns);\n        desc = _.defaultsDeep(base, desc);\n      }\n    }\n  }\n  return desc;\n};\n\nEnumerationElement.prototype.description = function () {\n  return this[this.valueKey];\n};\n\nComplexTypeElement.prototype.description = function (definitions, xmlns) {\n  let children = this.children || [];\n  for (let i = 0, child; child = children[i]; i++) {\n    if (child instanceof ChoiceElement ||\n      child instanceof SequenceElement ||\n      child instanceof AllElement ||\n      child instanceof SimpleContentElement ||\n      child instanceof ComplexContentElement) {\n\n      return child.description(definitions, xmlns);\n    }\n  }\n  return {};\n};\n\nComplexContentElement.prototype.description = function (definitions, xmlns) {\n  let children = this.children;\n  for (let i = 0, child; child = children[i]; i++) {\n    if (child instanceof ExtensionElement) {\n      return child.description(definitions, xmlns);\n    }\n  }\n  return {};\n};\n\nSimpleContentElement.prototype.description = function (definitions, xmlns) {\n  let children = this.children;\n  for (let i = 0, child; child = children[i]; i++) {\n    if (child instanceof ExtensionElement) {\n      return child.description(definitions, xmlns);\n    }\n  }\n  return {};\n};\n\nElementElement.prototype.description = function (definitions, xmlns) {\n  let element = {},\n    name = this.$name;\n  let isMany = !this.$maxOccurs ? false : (isNaN(this.$maxOccurs) ? (this.$maxOccurs === 'unbounded') : (this.$maxOccurs > 1));\n  if (this.$minOccurs !== this.$maxOccurs && isMany) {\n    name += '[]';\n  }\n\n  if (xmlns && xmlns[TNS_PREFIX]) {\n    this.$targetNamespace = xmlns[TNS_PREFIX];\n  }\n  let type = this.$type || this.$ref;\n  if (type) {\n    type = splitQName(type);\n    let typeName = type.name,\n      ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix],\n      schema = definitions.schemas[ns],\n      typeElement = schema && (this.$type ? schema.complexTypes[typeName] || schema.types[typeName] : schema.elements[typeName]);\n\n    if (ns && definitions.schemas[ns]) {\n      xmlns = definitions.schemas[ns].xmlns;\n    }\n\n    if (typeElement && !(typeName in Primitives)) {\n\n      if (!(typeName in definitions.descriptions.types)) {\n\n        let elem: any = {};\n        definitions.descriptions.types[typeName] = elem;\n        let description = typeElement.description(definitions, xmlns);\n        if (typeof description === 'string') {\n          elem = description;\n        }\n        else {\n          Object.keys(description).forEach(function (key) {\n            elem[key] = description[key];\n          });\n        }\n\n        if (this.$ref) {\n          element = elem;\n        }\n        else {\n          element[name] = elem;\n        }\n\n        if (typeof elem === 'object') {\n          elem.targetNSAlias = type.prefix;\n          elem.targetNamespace = ns;\n        }\n\n        definitions.descriptions.types[typeName] = elem;\n      }\n      else {\n        if (this.$ref) {\n          element = definitions.descriptions.types[typeName];\n        }\n        else {\n          element[name] = definitions.descriptions.types[typeName];\n        }\n      }\n\n    }\n    else {\n      element[name] = this.$type;\n    }\n  }\n  else {\n    let children = this.children;\n    element[name] = {};\n    for (let i = 0, child; child = children[i]; i++) {\n      if (child instanceof ComplexTypeElement) {\n        element[name] = child.description(definitions, xmlns);\n      }\n    }\n  }\n  return element;\n};\n\nAllElement.prototype.description =\n  SequenceElement.prototype.description = function (definitions, xmlns) {\n    let children = this.children;\n    let sequence = {};\n    for (let i = 0, child; child = children[i]; i++) {\n      if (child instanceof AnyElement) {\n        continue;\n      }\n      let description = child.description(definitions, xmlns);\n      for (let key in description) {\n        sequence[key] = description[key];\n      }\n    }\n    return sequence;\n  };\n\nChoiceElement.prototype.description = function (definitions, xmlns) {\n  let children = this.children;\n  let choice = {};\n  for (let i = 0, child; child = children[i]; i++) {\n    let description = child.description(definitions, xmlns);\n    for (let key in description) {\n      choice[key] = description[key];\n    }\n  }\n  return choice;\n};\n\nMessageElement.prototype.description = function (definitions) {\n  if (this.element) {\n    return this.element && this.element.description(definitions);\n  }\n  let desc = {};\n  desc[this.$name] = this.parts;\n  return desc;\n};\n\nPortTypeElement.prototype.description = function (definitions) {\n  let methods = {};\n  for (let name in this.methods) {\n    let method = this.methods[name];\n    methods[name] = method.description(definitions);\n  }\n  return methods;\n};\n\nOperationElement.prototype.description = function (definitions) {\n  let inputDesc = this.input ? this.input.description(definitions) : null;\n  let outputDesc = this.output ? this.output.description(definitions) : null;\n  return {\n    input: inputDesc && inputDesc[Object.keys(inputDesc)[0]],\n    output: outputDesc && outputDesc[Object.keys(outputDesc)[0]]\n  };\n};\n\nBindingElement.prototype.description = function (definitions) {\n  let methods = {};\n  for (let name in this.methods) {\n    let method = this.methods[name];\n    methods[name] = method.description(definitions);\n  }\n  return methods;\n};\n\nServiceElement.prototype.description = function (definitions) {\n  let ports = {};\n  for (let name in this.ports) {\n    let port = this.ports[name];\n    ports[name] = port.binding.description(definitions);\n  }\n  return ports;\n};\n\nexport let WSDL = function (definition, uri, options) {\n  let self = this,\n    fromFunc;\n\n  this.uri = uri;\n  this.callback = function () {\n  };\n  this._includesWsdl = [];\n\n  // initialize WSDL cache\n  this.WSDL_CACHE = (options || {}).WSDL_CACHE || {};\n\n  this._initializeOptions(options);\n\n  if (typeof definition === 'string') {\n    definition = stripBom(definition);\n    fromFunc = this._fromXML;\n  }\n  else if (typeof definition === 'object') {\n    fromFunc = this._fromServices;\n  }\n  else {\n    throw new Error('WSDL letructor takes either an XML string or service definition');\n  }\n\n  Promise.resolve(true).then(() => {\n    try {\n      fromFunc.call(self, definition);\n    } catch (e) {\n      return self.callback(e.message);\n    }\n\n    self.processIncludes().then(() => {\n      self.definitions.deleteFixedAttrs();\n      let services = self.services = self.definitions.services;\n      if (services) {\n        for (const name in services) {\n          services[name].postProcess(self.definitions);\n        }\n      }\n      let complexTypes = self.definitions.complexTypes;\n      if (complexTypes) {\n        for (const name in complexTypes) {\n          complexTypes[name].deleteFixedAttrs();\n        }\n      }\n\n      // for document style, for every binding, prepare input message element name to (methodName, output message element name) mapping\n      let bindings = self.definitions.bindings;\n      for (let bindingName in bindings) {\n        let binding = bindings[bindingName];\n        if (typeof binding.style === 'undefined') {\n          binding.style = 'document';\n        }\n        if (binding.style !== 'document')\n          continue;\n        let methods = binding.methods;\n        let topEls = binding.topElements = {};\n        for (let methodName in methods) {\n          if (methods[methodName].input) {\n            let inputName = methods[methodName].input.$name;\n            let outputName = \"\";\n            if (methods[methodName].output)\n              outputName = methods[methodName].output.$name;\n            topEls[inputName] = { \"methodName\": methodName, \"outputName\": outputName };\n          }\n        }\n      }\n\n      // prepare soap envelope xmlns definition string\n      self.xmlnsInEnvelope = self._xmlnsMap();\n      self.callback(null, self);\n    }).catch(err => self.callback(err));\n\n  });\n\n  // process.nextTick(function() {\n  //   try {\n  //     fromFunc.call(self, definition);\n  //   } catch (e) {\n  //     return self.callback(e.message);\n  //   }\n\n  //   self.processIncludes(function(err) {\n  //     let name;\n  //     if (err) {\n  //       return self.callback(err);\n  //     }\n\n  //     self.definitions.deleteFixedAttrs();\n  //     let services = self.services = self.definitions.services;\n  //     if (services) {\n  //       for (name in services) {\n  //         services[name].postProcess(self.definitions);\n  //       }\n  //     }\n  //     let complexTypes = self.definitions.complexTypes;\n  //     if (complexTypes) {\n  //       for (name in complexTypes) {\n  //         complexTypes[name].deleteFixedAttrs();\n  //       }\n  //     }\n\n  //     // for document style, for every binding, prepare input message element name to (methodName, output message element name) mapping\n  //     let bindings = self.definitions.bindings;\n  //     for (let bindingName in bindings) {\n  //       let binding = bindings[bindingName];\n  //       if (typeof binding.style === 'undefined') {\n  //         binding.style = 'document';\n  //       }\n  //       if (binding.style !== 'document')\n  //         continue;\n  //       let methods = binding.methods;\n  //       let topEls = binding.topElements = {};\n  //       for (let methodName in methods) {\n  //         if (methods[methodName].input) {\n  //           let inputName = methods[methodName].input.$name;\n  //           let outputName=\"\";\n  //           if(methods[methodName].output )\n  //             outputName = methods[methodName].output.$name;\n  //           topEls[inputName] = {\"methodName\": methodName, \"outputName\": outputName};\n  //         }\n  //       }\n  //     }\n\n  //     // prepare soap envelope xmlns definition string\n  //     self.xmlnsInEnvelope = self._xmlnsMap();\n\n  //     self.callback(err, self);\n  //   });\n\n  // });\n};\n\nWSDL.prototype.ignoredNamespaces = ['tns', 'targetNamespace', 'typedNamespace'];\n\nWSDL.prototype.ignoreBaseNameSpaces = false;\n\nWSDL.prototype.valueKey = '$value';\nWSDL.prototype.xmlKey = '$xml';\n\nWSDL.prototype._initializeOptions = function (options) {\n  this._originalIgnoredNamespaces = (options || {}).ignoredNamespaces;\n  this.options = {};\n\n  let ignoredNamespaces = options ? options.ignoredNamespaces : null;\n\n  if (ignoredNamespaces &&\n    (Array.isArray(ignoredNamespaces.namespaces) || typeof ignoredNamespaces.namespaces === 'string')) {\n    if (ignoredNamespaces.override) {\n      this.options.ignoredNamespaces = ignoredNamespaces.namespaces;\n    } else {\n      this.options.ignoredNamespaces = this.ignoredNamespaces.concat(ignoredNamespaces.namespaces);\n    }\n  } else {\n    this.options.ignoredNamespaces = this.ignoredNamespaces;\n  }\n\n  this.options.valueKey = options.valueKey || this.valueKey;\n  this.options.xmlKey = options.xmlKey || this.xmlKey;\n  if (options.escapeXML !== undefined) {\n    this.options.escapeXML = options.escapeXML;\n  } else {\n    this.options.escapeXML = true;\n  }\n  if (options.returnFault !== undefined) {\n    this.options.returnFault = options.returnFault;\n  } else {\n    this.options.returnFault = false;\n  }\n  this.options.handleNilAsNull = !!options.handleNilAsNull;\n\n  if (options.namespaceArrayElements !== undefined) {\n    this.options.namespaceArrayElements = options.namespaceArrayElements;\n  } else {\n    this.options.namespaceArrayElements = true;\n  }\n\n  // Allow any request headers to keep passing through\n  this.options.wsdl_headers = options.wsdl_headers;\n  this.options.wsdl_options = options.wsdl_options;\n  if (options.httpClient) {\n    this.options.httpClient = options.httpClient;\n  }\n\n  // The supplied request-object should be passed through\n  if (options.request) {\n    this.options.request = options.request;\n  }\n\n  let ignoreBaseNameSpaces = options ? options.ignoreBaseNameSpaces : null;\n  if (ignoreBaseNameSpaces !== null && typeof ignoreBaseNameSpaces !== 'undefined') {\n    this.options.ignoreBaseNameSpaces = ignoreBaseNameSpaces;\n  } else {\n    this.options.ignoreBaseNameSpaces = this.ignoreBaseNameSpaces;\n  }\n\n  // Works only in client\n  this.options.forceSoap12Headers = options.forceSoap12Headers;\n  this.options.customDeserializer = options.customDeserializer;\n\n  if (options.overrideRootElement !== undefined) {\n    this.options.overrideRootElement = options.overrideRootElement;\n  }\n\n  this.options.useEmptyTag = !!options.useEmptyTag;\n};\n\nWSDL.prototype.onReady = function (callback) {\n  if (callback)\n    this.callback = callback;\n};\n\nWSDL.prototype._processNextInclude = async function (includes) {\n  let self = this,\n    include = includes.shift(),\n    options;\n\n  if (!include)\n    return; // callback();\n\n  let includePath;\n  if (!/^https?:/.test(self.uri) && !/^https?:/.test(include.location)) {\n    // includePath = path.resolve(path.dirname(self.uri), include.location);\n  } else {\n    includePath = url.resolve(self.uri || '', include.location);\n  }\n\n  options = _.assign({}, this.options);\n  // follow supplied ignoredNamespaces option\n  options.ignoredNamespaces = this._originalIgnoredNamespaces || this.options.ignoredNamespaces;\n  options.WSDL_CACHE = this.WSDL_CACHE;\n\n  const wsdl = await open_wsdl_recursive(includePath, options)\n  self._includesWsdl.push(wsdl);\n\n  if (wsdl.definitions instanceof DefinitionsElement) {\n    _.mergeWith(self.definitions, wsdl.definitions, function (a, b) {\n      return (a instanceof SchemaElement) ? a.merge(b) : undefined;\n    });\n  } else {\n    self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace] = deepMerge(self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace], wsdl.definitions);\n  }\n\n  return self._processNextInclude(includes);\n\n  // open_wsdl_recursive(includePath, options, function(err, wsdl) {\n  //   if (err) {\n  //     return callback(err);\n  //   }\n\n  //   self._includesWsdl.push(wsdl);\n\n  //   if (wsdl.definitions instanceof DefinitionsElement) {\n  //     _.mergeWith(self.definitions, wsdl.definitions, function(a,b) {\n  //       return (a instanceof SchemaElement) ? a.merge(b) : undefined;\n  //     });\n  //   } else {\n  //     self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace] = deepMerge(self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace], wsdl.definitions);\n  //   }\n  //   self._processNextInclude(includes, function(err) {\n  //     callback(err);\n  //   });\n  // });\n};\n\nWSDL.prototype.processIncludes = async function () {\n  let schemas = this.definitions.schemas,\n    includes = [];\n\n  for (let ns in schemas) {\n    let schema = schemas[ns];\n    includes = includes.concat(schema.includes || []);\n  }\n\n  return this._processNextInclude(includes);\n};\n\nWSDL.prototype.describeServices = function () {\n  let services = {};\n  for (let name in this.services) {\n    let service = this.services[name];\n    services[name] = service.description(this.definitions);\n  }\n  return services;\n};\n\nWSDL.prototype.toXML = function () {\n  return this.xml || '';\n};\n\nWSDL.prototype.xmlToObject = function (xml, callback) {\n  let self = this;\n  let p = typeof callback === 'function' ? {} : sax.parser(true);\n  let objectName = null;\n  let root: any = {};\n  let schema={};\n  if(!this.options.forceSoap12Headers){\n     schema = {\n      Envelope: {\n        Header: {\n          Security: {\n            UsernameToken: {\n              Username: 'string',\n              Password: 'string'\n            }\n          }\n        },\n        Body: {\n          Fault: {\n            faultcode: 'string',\n            faultstring: 'string',\n            detail: 'string'\n          }\n        }\n      }\n    };\n  } else {\n     schema ={\n      Envelope: {\n        Header: {\n          Security: {\n            UsernameToken: {\n              Username: 'string',\n              Password: 'string'\n            }\n          }\n        },\n        Body:{\n          Code: {\n            Value: 'string',\n           Subcode:\n            {\n               Value: 'string' \n             } \n           },\n           Reason: { Text: 'string'},\n           statusCode: 'number',\n           Detail: 'object'\n         }\n\n        }\n      \n\n    }\n  }\n  \n  //console.log('schema',schema);\n  let stack: any[] = [{ name: null, object: root, schema: schema }];\n  let xmlns: any = {};\n\n  let refs = {}, id; // {id:{hrefs:[],obj:}, ...}\n\n  p.onopentag = function (node) {\n    let nsName = node.name;\n    let attrs: any = node.attributes;\n    let name = splitQName(nsName).name,\n      attributeName,\n      top = stack[stack.length - 1],\n      topSchema = top.schema,\n      elementAttributes = {},\n      hasNonXmlnsAttribute = false,\n      hasNilAttribute = false,\n      obj = {};\n    let originalName = name;\n\n    if (!objectName && top.name === 'Body' && name !== 'Fault') {\n      let message = self.definitions.messages[name];\n      // Support RPC/literal messages where response body contains one element named\n      // after the operation + 'Response'. See http://www.w3.org/TR/wsdl#_names\n      if (!message) {\n        try {\n          // Determine if this is request or response\n          let isInput = false;\n          let isOutput = false;\n          if ((/Response$/).test(name)) {\n            isOutput = true;\n            name = name.replace(/Response$/, '');\n          } else if ((/Request$/).test(name)) {\n            isInput = true;\n            name = name.replace(/Request$/, '');\n          } else if ((/Solicit$/).test(name)) {\n            isInput = true;\n            name = name.replace(/Solicit$/, '');\n          }\n          // Look up the appropriate message as given in the portType's operations\n          let portTypes = self.definitions.portTypes;\n          let portTypeNames = Object.keys(portTypes);\n          // Currently this supports only one portType definition.\n          let portType = portTypes[portTypeNames[0]];\n          if (isInput) {\n            name = portType.methods[name].input.$name;\n          } else {\n            name = portType.methods[name].output.$name;\n          }\n          message = self.definitions.messages[name];\n          // 'cache' this alias to speed future lookups\n          self.definitions.messages[originalName] = self.definitions.messages[name];\n        } catch (e) {\n          if (self.options.returnFault) {\n            p.onerror(e);\n          }\n        }\n      }\n\n      topSchema = message.description(self.definitions);\n      objectName = originalName;\n    }\n\n    if (attrs.href) {\n      id = attrs.href.substr(1);\n      if (!refs[id]) {\n        refs[id] = { hrefs: [], obj: null };\n      }\n      refs[id].hrefs.push({ par: top.object, key: name, obj: obj });\n    }\n    if (id = attrs.id) {\n      if (!refs[id]) {\n        refs[id] = { hrefs: [], obj: null };\n      }\n    }\n\n    //Handle element attributes\n    for (attributeName in attrs) {\n      if (/^xmlns:|^xmlns$/.test(attributeName)) {\n        xmlns[splitQName(attributeName).name] = attrs[attributeName];\n        continue;\n      }\n      hasNonXmlnsAttribute = true;\n      elementAttributes[attributeName] = attrs[attributeName];\n    }\n\n    for (attributeName in elementAttributes) {\n      let res = splitQName(attributeName);\n      if (res.name === 'nil' && xmlns[res.prefix] === 'http://www.w3.org/2001/XMLSchema-instance' && elementAttributes[attributeName] &&\n        (elementAttributes[attributeName].toLowerCase() === 'true' || elementAttributes[attributeName] === '1')\n      ) {\n        hasNilAttribute = true;\n        break;\n      }\n    }\n\n    if (hasNonXmlnsAttribute) {\n      obj[self.options.attributesKey] = elementAttributes;\n    }\n\n    // Pick up the schema for the type specified in element's xsi:type attribute.\n    let xsiTypeSchema;\n    let xsiType = elementAttributes['xsi:type'];\n    if (xsiType) {\n      let type = splitQName(xsiType);\n      let typeURI;\n      if (type.prefix === TNS_PREFIX) {\n        // In case of xsi:type = \"MyType\"\n        typeURI = xmlns[type.prefix] || xmlns.xmlns;\n      } else {\n        typeURI = xmlns[type.prefix];\n      }\n      let typeDef = self.findSchemaObject(typeURI, type.name);\n      if (typeDef) {\n        xsiTypeSchema = typeDef.description(self.definitions);\n      }\n    }\n\n    if (topSchema && topSchema[name + '[]']) {\n      name = name + '[]';\n    }\n    stack.push({\n      name: originalName,\n      object: obj,\n      schema: (xsiTypeSchema || (topSchema && topSchema[name])),\n      id: attrs.id,\n      nil: hasNilAttribute\n    });\n  };\n\n  p.onclosetag = function (nsName) {\n    let cur: any = stack.pop(),\n      obj = cur.object,\n      top = stack[stack.length - 1],\n      topObject = top.object,\n      topSchema = top.schema,\n      name = splitQName(nsName).name;\n\n    if (typeof cur.schema === 'string' && (cur.schema === 'string' || (<string>cur.schema).split(':')[1] === 'string')) {\n      if (typeof obj === 'object' && Object.keys(obj).length === 0) obj = cur.object = '';\n    }\n\n    if (cur.nil === true) {\n      if (self.options.handleNilAsNull) {\n        obj = null;\n      } else {\n        return;\n      }\n    }\n\n    if (_.isPlainObject(obj) && !Object.keys(obj).length) {\n      obj = null;\n    }\n\n    if (topSchema && topSchema[name + '[]']) {\n      if (!topObject[name]) {\n        topObject[name] = [];\n      }\n      topObject[name].push(obj);\n    } else if (name in topObject) {\n      if (!Array.isArray(topObject[name])) {\n        topObject[name] = [topObject[name]];\n      }\n      topObject[name].push(obj);\n    } else {\n      topObject[name] = obj;\n    }\n\n    if (cur.id) {\n      refs[cur.id].obj = obj;\n    }\n  };\n\n  p.oncdata = function (text) {\n    let originalText = text;\n    text = trim(text);\n    if (!text.length) {\n      return;\n    }\n\n    if (/<\\?xml[\\s\\S]+\\?>/.test(text)) {\n      let top = stack[stack.length - 1];\n      let value = self.xmlToObject(text);\n      if (top.object[self.options.attributesKey]) {\n        top.object[self.options.valueKey] = value;\n      } else {\n        top.object = value;\n      }\n    } else {\n      p.ontext(originalText);\n    }\n  };\n\n  p.onerror = function (e) {\n    p.resume();\n    throw {\n      Fault: {\n        faultcode: 500,\n        faultstring: 'Invalid XML',\n        detail: new Error(e).message,\n        statusCode: 500\n      }\n    };\n  };\n\n  p.ontext = function (text) {\n    let originalText = text;\n    text = trim(text);\n    if (!text.length) {\n      return;\n    }\n\n    let top = stack[stack.length - 1];\n    let name = splitQName(top.schema).name,\n      value;\n    if (self.options && self.options.customDeserializer && self.options.customDeserializer[name]) {\n      value = self.options.customDeserializer[name](text, top);\n    }\n    else {\n      if (name === 'int' || name === 'integer') {\n        value = parseInt(text, 10);\n      } else if (name === 'bool' || name === 'boolean') {\n        value = text.toLowerCase() === 'true' || text === '1';\n      } else if (name === 'dateTime' || name === 'date') {\n        value = new Date(text);\n      } else {\n        if (self.options.preserveWhitespace) {\n          text = originalText;\n        }\n        // handle string or other types\n        if (typeof top.object !== 'string') {\n          value = text;\n        } else {\n          value = top.object + text;\n        }\n      }\n    }\n\n    if (top.object[self.options.attributesKey]) {\n      top.object[self.options.valueKey] = value;\n    } else {\n      top.object = value;\n    }\n  };\n\n  if (typeof callback === 'function') {\n    // we be streaming\n    let saxStream = sax.createStream(true);\n    saxStream.on('opentag', p.onopentag);\n    saxStream.on('closetag', p.onclosetag);\n    saxStream.on('cdata', p.oncdata);\n    saxStream.on('text', p.ontext);\n    xml.pipe(saxStream)\n      .on('error', function (err) {\n        callback(err);\n      })\n      .on('end', function () {\n        let r;\n        try {\n          r = finish();\n        } catch (e) {\n          return callback(e);\n        }\n        callback(null, r);\n      });\n    return;\n  }\n  p.write(xml).close();\n\n  return finish();\n\n  function finish() {\n    // MultiRef support: merge objects instead of replacing\n    for (let n in refs) {\n      let ref = refs[n];\n      for (let i = 0; i < ref.hrefs.length; i++) {\n        _.assign(ref.hrefs[i].obj, ref.obj);\n      }\n    }\n\n    if (root.Envelope) {\n      let body = root.Envelope.Body;\n      let error: any;\n    \n      if (body && body.Fault) {\n        \n        if(!body.Fault.Code){\n        let code = body.Fault.faultcode && body.Fault.faultcode.$value;\n        let string = body.Fault.faultstring && body.Fault.faultstring.$value;\n        let detail = body.Fault.detail && body.Fault.detail.$value;\n\n        code = code || body.Fault.faultcode;\n        string = string || body.Fault.faultstring;\n        detail = detail || body.Fault.detail;\n\n         error = new Error(code + ': ' + string + (detail ? ': ' + detail : ''));\n        }else {\n          let code = body.Fault.Code.Value;\n          let string = body.Fault.Reason.Text.$value;\n          let detail = body.Fault.Detail.info;\n          error = new Error(code + ': ' + string + (detail ? ': ' + detail : '')); \n\n        }\n\n        error.root = root;\n        throw body.Fault;\n      }\n      return root.Envelope;\n    }\n    return root;\n  }\n};\n\n/**\n * Look up a XSD type or element by namespace URI and name\n * @param {String} nsURI Namespace URI\n * @param {String} qname Local or qualified name\n * @returns {*} The XSD type/element definition\n */\nWSDL.prototype.findSchemaObject = function (nsURI, qname) {\n  if (!nsURI || !qname) {\n    return null;\n  }\n\n  let def = null;\n\n  if (this.definitions.schemas) {\n    let schema = this.definitions.schemas[nsURI];\n    if (schema) {\n      if (qname.indexOf(':') !== -1) {\n        qname = qname.substring(qname.indexOf(':') + 1, qname.length);\n      }\n\n      // if the client passed an input element which has a `$lookupType` property instead of `$type`\n      // the `def` is found in `schema.elements`.\n      def = schema.complexTypes[qname] || schema.types[qname] || schema.elements[qname];\n    }\n  }\n\n  return def;\n};\n\n/**\n * Create document style xml string from the parameters\n * @param {String} name\n * @param {*} params\n * @param {String} nsPrefix\n * @param {String} nsURI\n * @param {String} type\n */\nWSDL.prototype.objectToDocumentXML = function (name, params, nsPrefix, nsURI, type) {\n  //If user supplies XML already, just use that.  XML Declaration should not be present.\n  if (params && params._xml) {\n    return params._xml;\n  }\n  let args = {};\n  args[name] = params;\n  let parameterTypeObj = type ? this.findSchemaObject(nsURI, type) : null;\n  return this.objectToXML(args, null, nsPrefix, nsURI, true, null, parameterTypeObj);\n};\n\n/**\n * Create RPC style xml string from the parameters\n * @param {String} name\n * @param {*} params\n * @param {String} nsPrefix\n * @param {String} nsURI\n * @returns {string}\n */\nWSDL.prototype.objectToRpcXML = function (name, params, nsPrefix, nsURI, isParts) {\n  let parts = [];\n  let defs = this.definitions;\n  let nsAttrName = '_xmlns';\n\n  nsPrefix = nsPrefix || findPrefix(defs.xmlns, nsURI);\n\n  nsURI = nsURI || defs.xmlns[nsPrefix];\n  nsPrefix = nsPrefix === TNS_PREFIX ? '' : (nsPrefix + ':');\n\n  parts.push(['<', nsPrefix, name, '>'].join(''));\n\n  for (let key in params) {\n    if (!params.hasOwnProperty(key)) {\n      continue;\n    }\n    if (key !== nsAttrName) {\n      let value = params[key];\n      let prefixedKey = (isParts ? '' : nsPrefix) + key;\n      let attributes = [];\n      if (typeof value === 'object' && value.hasOwnProperty(this.options.attributesKey)) {\n        let attrs = value[this.options.attributesKey];\n        for (let n in attrs) {\n          attributes.push(' ' + n + '=' + '\"' + attrs[n] + '\"');\n        }\n      }\n      parts.push(['<', prefixedKey].concat(attributes).concat('>').join(''));\n      parts.push((typeof value === 'object') ? this.objectToXML(value, key, nsPrefix, nsURI) : xmlEscape(value));\n      parts.push(['</', prefixedKey, '>'].join(''));\n    }\n  }\n  parts.push(['</', nsPrefix, name, '>'].join(''));\n  return parts.join('');\n};\n\n\nfunction appendColon(ns) {\n  return (ns && ns.charAt(ns.length - 1) !== ':') ? ns + ':' : ns;\n}\n\nfunction noColonNameSpace(ns) {\n  return (ns && ns.charAt(ns.length - 1) === ':') ? ns.substring(0, ns.length - 1) : ns;\n}\n\nWSDL.prototype.isIgnoredNameSpace = function (ns) {\n  return this.options.ignoredNamespaces.indexOf(ns) > -1;\n};\n\nWSDL.prototype.filterOutIgnoredNameSpace = function (ns) {\n  let namespace = noColonNameSpace(ns);\n  return this.isIgnoredNameSpace(namespace) ? '' : namespace;\n};\n\n\n\n/**\n * Convert an object to XML.  This is a recursive method as it calls itself.\n *\n * @param {Object} obj the object to convert.\n * @param {String} name the name of the element (if the object being traversed is\n * an element).\n * @param {String} nsPrefix the namespace prefix of the object I.E. xsd.\n * @param {String} nsURI the full namespace of the object I.E. http://w3.org/schema.\n * @param {Boolean} isFirst whether or not this is the first item being traversed.\n * @param {?} xmlnsAttr\n * @param {?} parameterTypeObject\n * @param {NamespaceContext} nsContext Namespace context\n */\nWSDL.prototype.objectToXML = function (obj, name, nsPrefix, nsURI, isFirst, xmlnsAttr, schemaObject, nsContext) {\n  let self = this;\n  let schema = this.definitions.schemas[nsURI];\n\n  let parentNsPrefix = nsPrefix ? nsPrefix.parent : undefined;\n  if (typeof parentNsPrefix !== 'undefined') {\n    //we got the parentNsPrefix for our array. setting the namespace-letiable back to the current namespace string\n    nsPrefix = nsPrefix.current;\n  }\n\n  parentNsPrefix = noColonNameSpace(parentNsPrefix);\n  if (this.isIgnoredNameSpace(parentNsPrefix)) {\n    parentNsPrefix = '';\n  }\n\n  let soapHeader = !schema;\n  let qualified = schema && schema.$elementFormDefault === 'qualified';\n  let parts = [];\n  let prefixNamespace = (nsPrefix || qualified) && nsPrefix !== TNS_PREFIX;\n\n  let xmlnsAttrib = '';\n  if (nsURI && isFirst) {\n    if (self.options.overrideRootElement && self.options.overrideRootElement.xmlnsAttributes) {\n      self.options.overrideRootElement.xmlnsAttributes.forEach(function (attribute) {\n        xmlnsAttrib += ' ' + attribute.name + '=\"' + attribute.value + '\"';\n      });\n    } else {\n      if (prefixNamespace && !this.isIgnoredNameSpace(nsPrefix)) {\n        // resolve the prefix namespace\n        xmlnsAttrib += ' xmlns:' + nsPrefix + '=\"' + nsURI + '\"';\n      }\n      // only add default namespace if the schema elementFormDefault is qualified\n      if (qualified || soapHeader) xmlnsAttrib += ' xmlns=\"' + nsURI + '\"';\n    }\n  }\n\n  if (!nsContext) {\n    nsContext = new NamespaceContext();\n    nsContext.declareNamespace(nsPrefix, nsURI);\n  } else {\n    nsContext.pushContext();\n  }\n\n  // explicitly use xmlns attribute if available\n  if (xmlnsAttr && !(self.options.overrideRootElement && self.options.overrideRootElement.xmlnsAttributes)) {\n    xmlnsAttrib = xmlnsAttr;\n  }\n\n  let ns = '';\n\n  if (self.options.overrideRootElement && isFirst) {\n    ns = self.options.overrideRootElement.namespace;\n  } else if (prefixNamespace && (qualified || isFirst || soapHeader) && !this.isIgnoredNameSpace(nsPrefix)) {\n    ns = nsPrefix;\n  }\n\n  let i, n;\n  // start building out XML string.\n  if (Array.isArray(obj)) {\n    for (i = 0, n = obj.length; i < n; i++) {\n      let item = obj[i];\n      let arrayAttr = self.processAttributes(item, nsContext),\n        correctOuterNsPrefix = parentNsPrefix || ns; //using the parent namespace prefix if given\n\n      let body = self.objectToXML(item, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);\n\n      let openingTagParts = ['<', appendColon(correctOuterNsPrefix), name, arrayAttr, xmlnsAttrib];\n\n      if (body === '' && self.options.useEmptyTag) {\n        // Use empty (self-closing) tags if no contents\n        openingTagParts.push(' />');\n        parts.push(openingTagParts.join(''));\n      } else {\n        openingTagParts.push('>');\n        if (self.options.namespaceArrayElements || i === 0) {\n          parts.push(openingTagParts.join(''));\n        }\n        parts.push(body);\n        if (self.options.namespaceArrayElements || i === n - 1) {\n          parts.push(['</', appendColon(correctOuterNsPrefix), name, '>'].join(''));\n        }\n      }\n    }\n  } else if (typeof obj === 'object') {\n    for (name in obj) {\n      if (!obj.hasOwnProperty(name)) continue;\n      //don't process attributes as element\n      if (name === self.options.attributesKey) {\n        continue;\n      }\n      //Its the value of a xml object. Return it directly.\n      if (name === self.options.xmlKey) {\n        nsContext.popContext();\n        return obj[name];\n      }\n      //Its the value of an item. Return it directly.\n      if (name === self.options.valueKey) {\n        nsContext.popContext();\n        return xmlEscape(obj[name]);\n      }\n\n      let child = obj[name];\n      if (typeof child === 'undefined') {\n        continue;\n      }\n\n      let attr = self.processAttributes(child, nsContext);\n\n      let value = '';\n      let nonSubNameSpace = '';\n      let emptyNonSubNameSpace = false;\n\n      let nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);\n      if (nameWithNsRegex) {\n        nonSubNameSpace = nameWithNsRegex[1] + ':';\n        name = nameWithNsRegex[2];\n      } else if (name[0] === ':') {\n        emptyNonSubNameSpace = true;\n        name = name.substr(1);\n      }\n\n      if (isFirst) {\n        value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);\n      } else {\n\n        if (self.definitions.schemas) {\n          if (schema) {\n            let childSchemaObject = self.findChildSchemaObject(schemaObject, name);\n            //find sub namespace if not a primitive\n            if (childSchemaObject &&\n              ((childSchemaObject.$type && (childSchemaObject.$type.indexOf('xsd:') === -1)) ||\n                childSchemaObject.$ref || childSchemaObject.$name)) {\n              /*if the base name space of the children is not in the ingoredSchemaNamspaces we use it.\n               This is because in some services the child nodes do not need the baseNameSpace.\n               */\n\n              let childNsPrefix: any = '';\n              let childName = '';\n              let childNsURI;\n              let childXmlnsAttrib = '';\n\n              let elementQName = childSchemaObject.$ref || childSchemaObject.$name;\n              if (elementQName) {\n                elementQName = splitQName(elementQName);\n                childName = elementQName.name;\n                if (elementQName.prefix === TNS_PREFIX) {\n                  // Local element\n                  childNsURI = childSchemaObject.$targetNamespace;\n                  childNsPrefix = nsContext.registerNamespace(childNsURI);\n                  if (this.isIgnoredNameSpace(childNsPrefix)) {\n                    childNsPrefix = nsPrefix;\n                  }\n                } else {\n                  childNsPrefix = elementQName.prefix;\n                  if (this.isIgnoredNameSpace(childNsPrefix)) {\n                    childNsPrefix = nsPrefix;\n                  }\n                  childNsURI = schema.xmlns[childNsPrefix] || self.definitions.xmlns[childNsPrefix];\n                }\n\n                let unqualified = false;\n                // Check qualification form for local elements\n                if (childSchemaObject.$name && childSchemaObject.targetNamespace === undefined) {\n                  if (childSchemaObject.$form === 'unqualified') {\n                    unqualified = true;\n                  } else if (childSchemaObject.$form === 'qualified') {\n                    unqualified = false;\n                  } else {\n                    unqualified = schema.$elementFormDefault !== 'qualified';\n                  }\n                }\n                if (unqualified) {\n                  childNsPrefix = '';\n                }\n\n                if (childNsURI && childNsPrefix) {\n                  if (nsContext.declareNamespace(childNsPrefix, childNsURI)) {\n                    childXmlnsAttrib = ' xmlns:' + childNsPrefix + '=\"' + childNsURI + '\"';\n                    xmlnsAttrib += childXmlnsAttrib;\n                  }\n                }\n              }\n\n              let resolvedChildSchemaObject;\n              if (childSchemaObject.$type) {\n                let typeQName = splitQName(childSchemaObject.$type);\n                let typePrefix = typeQName.prefix;\n                let typeURI = schema.xmlns[typePrefix] || self.definitions.xmlns[typePrefix];\n                childNsURI = typeURI;\n                if (typeURI !== 'http://www.w3.org/2001/XMLSchema' && typePrefix !== TNS_PREFIX) {\n                  // Add the prefix/namespace mapping, but not declare it\n                  nsContext.addNamespace(typePrefix, typeURI);\n                }\n                resolvedChildSchemaObject =\n                  self.findSchemaType(typeQName.name, typeURI) || childSchemaObject;\n              } else {\n                resolvedChildSchemaObject =\n                  self.findSchemaObject(childNsURI, childName) || childSchemaObject;\n              }\n\n              if (childSchemaObject.$baseNameSpace && this.options.ignoreBaseNameSpaces) {\n                childNsPrefix = nsPrefix;\n                childNsURI = nsURI;\n              }\n\n              if (this.options.ignoreBaseNameSpaces) {\n                childNsPrefix = '';\n                childNsURI = '';\n              }\n\n              ns = childNsPrefix;\n\n              if (Array.isArray(child)) {\n                //for arrays, we need to remember the current namespace\n                childNsPrefix = {\n                  current: childNsPrefix,\n                  parent: ns\n                };\n              } else {\n                //parent (array) already got the namespace\n                childXmlnsAttrib = null;\n              }\n\n              value = self.objectToXML(child, name, childNsPrefix, childNsURI,\n                false, childXmlnsAttrib, resolvedChildSchemaObject, nsContext);\n            } else if (obj[self.options.attributesKey] && obj[self.options.attributesKey].xsi_type) {\n              //if parent object has complex type defined and child not found in parent\n              let completeChildParamTypeObject = self.findChildSchemaObject(\n                obj[self.options.attributesKey].xsi_type.type,\n                obj[self.options.attributesKey].xsi_type.xmlns);\n\n              nonSubNameSpace = obj[self.options.attributesKey].xsi_type.prefix;\n              nsContext.addNamespace(obj[self.options.attributesKey].xsi_type.prefix,\n                obj[self.options.attributesKey].xsi_type.xmlns);\n              value = self.objectToXML(child, name, obj[self.options.attributesKey].xsi_type.prefix,\n                obj[self.options.attributesKey].xsi_type.xmlns, false, null, null, nsContext);\n            } else {\n              if (Array.isArray(child)) {\n                name = nonSubNameSpace + name;\n              }\n\n              value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\n            }\n          } else {\n            value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\n          }\n        }\n      }\n\n      ns = noColonNameSpace(ns);\n      if (prefixNamespace && !qualified && isFirst && !self.options.overrideRootElement) {\n        ns = nsPrefix;\n      } else if (this.isIgnoredNameSpace(ns)) {\n        ns = '';\n      }\n\n      let useEmptyTag = !value && self.options.useEmptyTag;\n      if (!Array.isArray(child)) {\n        // start tag\n        parts.push(['<', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, attr, xmlnsAttrib,\n          (child === null ? ' xsi:nil=\"true\"' : ''),\n          useEmptyTag ? ' />' : '>'\n        ].join(''));\n      }\n\n      if (!useEmptyTag) {\n        parts.push(value);\n        if (!Array.isArray(child)) {\n          // end tag\n          parts.push(['</', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, '>'].join(''));\n        }\n      }\n    }\n  } else if (obj !== undefined) {\n    parts.push((self.options.escapeXML) ? xmlEscape(obj) : obj);\n  }\n  nsContext.popContext();\n  return parts.join('');\n};\n\nWSDL.prototype.processAttributes = function (child, nsContext) {\n  let attr = '';\n\n  if (child === null) {\n    child = [];\n  }\n\n  let attrObj = child[this.options.attributesKey];\n  if (attrObj && attrObj.xsi_type) {\n    let xsiType = attrObj.xsi_type;\n\n    let prefix = xsiType.prefix || xsiType.namespace;\n    // Generate a new namespace for complex extension if one not provided\n    if (!prefix) {\n      prefix = nsContext.registerNamespace(xsiType.xmlns);\n    } else {\n      nsContext.declareNamespace(prefix, xsiType.xmlns);\n    }\n    xsiType.prefix = prefix;\n  }\n\n\n  if (attrObj) {\n    for (let attrKey in attrObj) {\n      //handle complex extension separately\n      if (attrKey === 'xsi_type') {\n        let attrValue = attrObj[attrKey];\n        attr += ' xsi:type=\"' + attrValue.prefix + ':' + attrValue.type + '\"';\n        attr += ' xmlns:' + attrValue.prefix + '=\"' + attrValue.xmlns + '\"';\n\n        continue;\n      } else {\n        attr += ' ' + attrKey + '=\"' + xmlEscape(attrObj[attrKey]) + '\"';\n      }\n    }\n  }\n\n  return attr;\n};\n\n/**\n * Look up a schema type definition\n * @param name\n * @param nsURI\n * @returns {*}\n */\nWSDL.prototype.findSchemaType = function (name, nsURI) {\n  if (!this.definitions.schemas || !name || !nsURI) {\n    return null;\n  }\n\n  let schema = this.definitions.schemas[nsURI];\n  if (!schema || !schema.complexTypes) {\n    return null;\n  }\n\n  return schema.complexTypes[name];\n};\n\nWSDL.prototype.findChildSchemaObject = function (parameterTypeObj, childName, backtrace) {\n  if (!parameterTypeObj || !childName) {\n    return null;\n  }\n\n  if (!backtrace) {\n    backtrace = [];\n  }\n\n  if (backtrace.indexOf(parameterTypeObj) >= 0) {\n    // We've recursed back to ourselves; break.\n    return null;\n  } else {\n    backtrace = backtrace.concat([parameterTypeObj]);\n  }\n\n  let found = null,\n    i = 0,\n    child,\n    ref;\n\n  if (Array.isArray(parameterTypeObj.$lookupTypes) && parameterTypeObj.$lookupTypes.length) {\n    let types = parameterTypeObj.$lookupTypes;\n\n    for (i = 0; i < types.length; i++) {\n      let typeObj = types[i];\n\n      if (typeObj.$name === childName) {\n        found = typeObj;\n        break;\n      }\n    }\n  }\n\n  let object = parameterTypeObj;\n  if (object.$name === childName && object.name === 'element') {\n    return object;\n  }\n  if (object.$ref) {\n    ref = splitQName(object.$ref);\n    if (ref.name === childName) {\n      return object;\n    }\n  }\n\n  let childNsURI;\n\n  // want to avoid unecessary recursion to improve performance\n  if (object.$type && backtrace.length === 1) {\n    let typeInfo = splitQName(object.$type);\n    if (typeInfo.prefix === TNS_PREFIX) {\n      childNsURI = parameterTypeObj.$targetNamespace;\n    } else {\n      childNsURI = this.definitions.xmlns[typeInfo.prefix];\n    }\n    let typeDef = this.findSchemaType(typeInfo.name, childNsURI);\n    if (typeDef) {\n      return this.findChildSchemaObject(typeDef, childName, backtrace);\n    }\n  }\n\n  if (object.children) {\n    for (i = 0, child; child = object.children[i]; i++) {\n      found = this.findChildSchemaObject(child, childName, backtrace);\n      if (found) {\n        break;\n      }\n\n      if (child.$base) {\n        let baseQName = splitQName(child.$base);\n        let childNameSpace = baseQName.prefix === TNS_PREFIX ? '' : baseQName.prefix;\n        childNsURI = child.xmlns[baseQName.prefix] || this.definitions.xmlns[baseQName.prefix];\n\n        let foundBase = this.findSchemaType(baseQName.name, childNsURI);\n\n        if (foundBase) {\n          found = this.findChildSchemaObject(foundBase, childName, backtrace);\n\n          if (found) {\n            found.$baseNameSpace = childNameSpace;\n            found.$type = childNameSpace + ':' + childName;\n            break;\n          }\n        }\n      }\n    }\n\n  }\n\n  if (!found && object.$name === childName) {\n    return object;\n  }\n\n  return found;\n};\n\nWSDL.prototype._parse = function (xml) {\n  let self = this,\n    p = sax.parser(true),\n    stack = [],\n    root = null,\n    types = null,\n    schema = null,\n    options = self.options;\n\n  p.onopentag = function (node) {\n    let nsName = node.name;\n    let attrs = node.attributes;\n\n    let top = stack[stack.length - 1];\n    let name;\n    if (top) {\n      try {\n        top.startElement(stack, nsName, attrs, options);\n      } catch (e) {\n        if (self.options.strict) {\n          throw e;\n        } else {\n          stack.push(new Element(nsName, attrs, options));\n        }\n      }\n    } else {\n      name = splitQName(nsName).name;\n      if (name === 'definitions') {\n        root = new DefinitionsElement(nsName, attrs, options);\n        stack.push(root);\n      } else if (name === 'schema') {\n        // Shim a structure in here to allow the proper objects to be created when merging back.\n        root = new DefinitionsElement('definitions', {}, {});\n        types = new TypesElement('types', {}, {});\n        schema = new SchemaElement(nsName, attrs, options);\n        types.addChild(schema);\n        root.addChild(types);\n        stack.push(schema);\n      } else {\n        throw new Error('Unexpected root element of WSDL or include');\n      }\n    }\n  };\n\n  p.onclosetag = function (name) {\n    let top = stack[stack.length - 1];\n    assert(top, 'Unmatched close tag: ' + name);\n\n    top.endElement(stack, name);\n  };\n\n  p.write(xml).close();\n\n  return root;\n};\n\nWSDL.prototype._fromXML = function (xml) {\n  this.definitions = this._parse(xml);\n  this.definitions.descriptions = {\n    types: {}\n  };\n  this.xml = xml;\n};\n\nWSDL.prototype._fromServices = function (services) {\n\n};\n\n\n\nWSDL.prototype._xmlnsMap = function () {\n  let xmlns = this.definitions.xmlns;\n  let str = '';\n  for (let alias in xmlns) {\n    if (alias === '' || alias === TNS_PREFIX) {\n      continue;\n    }\n    let ns = xmlns[alias];\n    switch (ns) {\n      case \"http://xml.apache.org/xml-soap\": // apachesoap\n      case \"http://schemas.xmlsoap.org/wsdl/\": // wsdl\n      case \"http://schemas.xmlsoap.org/wsdl/soap/\": // wsdlsoap\n      case \"http://schemas.xmlsoap.org/wsdl/soap12/\": // wsdlsoap12\n      case \"http://schemas.xmlsoap.org/soap/encoding/\": // soapenc\n      case \"http://www.w3.org/2001/XMLSchema\": // xsd\n        continue;\n    }\n    if (~ns.indexOf('http://schemas.xmlsoap.org/')) {\n      continue;\n    }\n    if (~ns.indexOf('http://www.w3.org/')) {\n      continue;\n    }\n    if (~ns.indexOf('http://xml.apache.org/')) {\n      continue;\n    }\n    str += ' xmlns:' + alias + '=\"' + ns + '\"';\n  }\n  return str;\n};\n\n/*\n * Have another function to load previous WSDLs as we\n * don't want this to be invoked externally (expect for tests)\n * This will attempt to fix circular dependencies with XSD files,\n * Given\n * - file.wsdl\n *   - xs:import namespace=\"A\" schemaLocation: A.xsd\n * - A.xsd\n *   - xs:import namespace=\"B\" schemaLocation: B.xsd\n * - B.xsd\n *   - xs:import namespace=\"A\" schemaLocation: A.xsd\n * file.wsdl will start loading, import A, then A will import B, which will then import A\n * Because A has already started to load previously it will be returned right away and\n * have an internal circular reference\n * B would then complete loading, then A, then file.wsdl\n * By the time file A starts processing its includes its definitions will be already loaded,\n * this is the only thing that B will depend on when \"opening\" A\n */\nfunction open_wsdl_recursive(uri, options): Promise<any> {\n  let fromCache,\n    WSDL_CACHE;\n\n  // if (typeof options === 'function') {\n  //   callback = options;\n  //   options = {};\n  // }\n\n  WSDL_CACHE = options.WSDL_CACHE;\n\n  if (fromCache = WSDL_CACHE[uri]) {\n    // return callback.call(fromCache, null, fromCache);\n    return fromCache;\n  }\n\n  return open_wsdl(uri, options);\n}\n\nexport async function open_wsdl(uri, options): Promise<any> {\n  // if (typeof options === 'function') {\n  //   callback = options;\n  //   options = {};\n  // }\n\n  // initialize cache when calling open_wsdl directly\n  let WSDL_CACHE = options.WSDL_CACHE || {};\n  let request_headers = options.wsdl_headers;\n  let request_options = options.wsdl_options;\n\n  // let wsdl;\n  // if (!/^https?:/.test(uri)) {\n  //   // debug('Reading file: %s', uri);\n  //   // fs.readFile(uri, 'utf8', function(err, definition) {\n  //   //   if (err) {\n  //   //     callback(err);\n  //   //   }\n  //   //   else {\n  //   //     wsdl = new WSDL(definition, uri, options);\n  //   //     WSDL_CACHE[ uri ] = wsdl;\n  //   //     wsdl.WSDL_CACHE = WSDL_CACHE;\n  //   //     wsdl.onReady(callback);\n  //   //   }\n  //   // });\n  // }\n  // else {\n  //   debug('Reading url: %s', uri);\n  //   let httpClient = options.httpClient || new HttpClient(options);\n  //   httpClient.request(uri, null /* options */, function(err, response, definition) {\n  //     if (err) {\n  //       callback(err);\n  //     } else if (response && response.statusCode === 200) {\n  //       wsdl = new WSDL(definition, uri, options);\n  //       WSDL_CACHE[ uri ] = wsdl;\n  //       wsdl.WSDL_CACHE = WSDL_CACHE;\n  //       wsdl.onReady(callback);\n  //     } else {\n  //       callback(new Error('Invalid WSDL URL: ' + uri + \"\\n\\n\\r Code: \" + response.statusCode + \"\\n\\n\\r Response Body: \" + response.body));\n  //     }\n  //   }, request_headers, request_options);\n  // }\n  // return wsdl;\n\n  console.log('Reading url: %s', uri);\n  const httpClient: HttpClient = options.httpClient;\n  const wsdlDef = await httpClient.get(uri, { responseType: 'text' }).toPromise();\n  const wsdlObj = await new Promise((resolve) => {\n    const wsdl = new WSDL(wsdlDef, uri, options);\n    WSDL_CACHE[uri] = wsdl;\n    wsdl.WSDL_CACHE = WSDL_CACHE;\n    wsdl.onReady(resolve(wsdl));\n  });\n  //console.log(\"wsdl\", wsdlObj)\n  return wsdlObj;\n}\n","import * as _ from 'lodash';\nimport { Buffer } from 'buffer';\n\nexport function BasicAuthSecurity(username, password, defaults) {\n  this._username = username;\n  this._password = password;\n  this.defaults = {};\n  _.merge(this.defaults, defaults);\n}\n\nBasicAuthSecurity.prototype.addHeaders = function(headers) {\n  headers.Authorization = 'Basic ' + new Buffer((this._username + ':' + this._password) || '').toString('base64');\n};\n\nBasicAuthSecurity.prototype.toXML = function() {\n  return '';\n};\n\nBasicAuthSecurity.prototype.addOptions = function(options) {\n  _.merge(options, this.defaults);\n};\n","\"use strict\";\n\n// var crypto = require('crypto');\nimport sha1 from 'crypto-js/sha1';\nimport Base64 from 'crypto-js/enc-base64';\n\n// var passwordDigest = require('../utils').passwordDigest;\nimport { passwordDigest } from '../utils';\n\nvar validPasswordTypes = ['PasswordDigest', 'PasswordText'];\n\nexport function WSSecurity(username, password, options) {\n  options = options || {};\n  this._username = username;\n  this._password = password;\n  //must account for backward compatibility for passwordType String param as well as object options defaults: passwordType = 'PasswordText', hasTimeStamp = true   \n  if (typeof options === 'string') {\n    this._passwordType = options ? options : 'PasswordText';\n    options = {};\n  } else {\n    this._passwordType = options.passwordType ? options.passwordType : 'PasswordText';\n  }\n\n  if (validPasswordTypes.indexOf(this._passwordType) === -1) {\n    this._passwordType = 'PasswordText';\n  }\n\n  this._hasTimeStamp = options.hasTimeStamp || typeof options.hasTimeStamp === 'boolean' ? !!options.hasTimeStamp : true;\n  /*jshint eqnull:true */\n  if (options.hasNonce != null) {\n    this._hasNonce = !!options.hasNonce;\n  }\n  this._hasTokenCreated = options.hasTokenCreated || typeof options.hasTokenCreated === 'boolean' ? !!options.hasTokenCreated : true;\n  if (options.actor != null) {\n    this._actor = options.actor;\n  }\n  if (options.mustUnderstand != null) {\n    this._mustUnderstand = !!options.mustUnderstand;\n  }\n}\n\nWSSecurity.prototype.toXML = function() {\n  // avoid dependency on date formatting libraries\n  function getDate(d) {\n    function pad(n) {\n      return n < 10 ? '0' + n : n;\n    }\n    return d.getUTCFullYear() + '-'\n      + pad(d.getUTCMonth() + 1) + '-'\n      + pad(d.getUTCDate()) + 'T'\n      + pad(d.getUTCHours()) + ':'\n      + pad(d.getUTCMinutes()) + ':'\n      + pad(d.getUTCSeconds()) + 'Z';\n  }\n  var now = new Date();\n  var created = getDate(now);\n  var timeStampXml = '';\n  if (this._hasTimeStamp) {\n    var expires = getDate( new Date(now.getTime() + (1000 * 600)) );\n    timeStampXml = \"<wsu:Timestamp wsu:Id=\\\"Timestamp-\"+created+\"\\\">\" +\n      \"<wsu:Created>\"+created+\"</wsu:Created>\" +\n      \"<wsu:Expires>\"+expires+\"</wsu:Expires>\" +\n      \"</wsu:Timestamp>\";\n  }\n\n  var password, nonce;\n  if (this._hasNonce || this._passwordType !== 'PasswordText') {\n    // nonce = base64 ( sha1 ( created + random ) )\n    // var nHash = crypto.createHash('sha1');\n    // nHash.update(created + Math.random());\n    // nonce = nHash.digest('base64');\n    nonce = Base64.stringify(sha1(created + Math.random(), ''));\n  }\n  if (this._passwordType === 'PasswordText') {\n    password = \"<wsse:Password Type=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText\\\">\" + this._password + \"</wsse:Password>\";\n    if (nonce) {\n      password += \"<wsse:Nonce EncodingType=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\\\">\" + nonce + \"</wsse:Nonce>\";\n    }\n  } else {\n    password = \"<wsse:Password Type=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\\\">\" + passwordDigest(nonce, created, this._password) + \"</wsse:Password>\" +\n      \"<wsse:Nonce EncodingType=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\\\">\" + nonce + \"</wsse:Nonce>\";\n  }\n\n  return \"<wsse:Security \" + (this._actor ? \"soap:actor=\\\"\" + this._actor + \"\\\" \" : \"\") +\n    (this._mustUnderstand ? \"soap:mustUnderstand=\\\"1\\\" \" : \"\") +\n    \"xmlns:wsse=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\\\" xmlns:wsu=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\\\">\" +\n    timeStampXml +\n    \"<wsse:UsernameToken xmlns:wsu=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\\\" wsu:Id=\\\"SecurityToken-\" + created + \"\\\">\" +\n    \"<wsse:Username>\" + this._username + \"</wsse:Username>\" +\n    password +\n    (this._hasTokenCreated ? \"<wsu:Created>\" + created + \"</wsu:Created>\" : \"\") +\n    \"</wsse:UsernameToken>\" +\n    \"</wsse:Security>\";\n};\n\n// module.exports = WSSecurity;\n","\"use strict\";\n\n// var _ = require('lodash');\nimport * as _ from 'lodash';\n\nexport function BearerSecurity(token, defaults) {\n\tthis._token = token;\n\tthis.defaults = {};\n\t_.merge(this.defaults, defaults);\n}\n\nBearerSecurity.prototype.addHeaders = function(headers) {\n\theaders.Authorization = \"Bearer \" + this._token;\n};\n\nBearerSecurity.prototype.toXML = function() {\n\treturn '';\n};\n\nBearerSecurity.prototype.addOptions = function(options) {\n  _.merge(options, this.defaults);\n};\n\n// module.exports = BearerSecurity;\n","\"use strict\";\n\n// var _ = require('lodash');\nimport * as _ from 'lodash';\n\nexport function NTLMSecurity(username, password, domain, workstation) {\n  if (typeof username === \"object\") {\n    this.defaults = username;\n    this.defaults.ntlm = true;\n  } else {\n    this.defaults = {\n      ntlm: true,\n      username: username,\n      password: password,\n      domain: domain,\n      workstation: workstation\n    };\n  }\n}\n\nNTLMSecurity.prototype.addHeaders = function (headers) {\n  headers.Connection = 'keep-alive';\n};\n\nNTLMSecurity.prototype.toXML = function () {\n  return '';\n};\n\nNTLMSecurity.prototype.addOptions = function (options) {\n  _.merge(options, this.defaults);\n};\n\n// module.exports = NTLMSecurity;\n","\"use strict\";\n\nimport {ÃÂ BasicAuthSecurity } from './BasicAuthSecurity';\nimport { WSSecurity } from './WSSecurity';\n// import { WSSecurityCert } from './WSSecurityCert';\nimport { BearerSecurity } from './BearerSecurity';\nimport { NTLMSecurity } from './NTLMSecurity';\n\nexport const security = { \n  BasicAuthSecurity,\n  BearerSecurity,\n  WSSecurity,\n  // WSSecurityCert,\n  NTLMSecurity,\n  // ClientSSLSecurity,\n  // ClientSSLSecurityPFX\n};","/*\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\n * MIT Licensed\n */\n\nimport { HttpClient, HttpResponse }ÃÂ from '@angular/common/http';\nimport * as assert from 'assert';\n import * as events from 'events';\n import * as util from 'util';\nimport { findPrefix } from './utils';\nimport * as _ from 'lodash';\nimport uuid4 from 'uuid/v4';\nimport { Observable, throwError } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst nonIdentifierChars = /[^a-z$_0-9]/i;\n\nexport const Client = function(wsdl, endpoint, options) {\n  events.EventEmitter.call(this);\n  options = options || {};\n  this.wsdl = wsdl;\n  this._initializeOptions(options);\n  this._initializeServices(endpoint);\n  this.httpClient = options.httpClient as HttpClient;\n  const promiseOptions: any = { multiArgs: true };\n  if (options.overridePromiseSuffix) {\n    promiseOptions.suffix = options.overridePromiseSuffix;\n  }\n  Promise.all([this, promiseOptions]);\n};\n util.inherits(Client, events.EventEmitter);\n\nClient.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {\n  if (!this.soapHeaders) {\n    this.soapHeaders = [];\n  }\n  if (typeof soapHeader === 'object') {\n    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);\n  }\n  return this.soapHeaders.push(soapHeader) - 1;\n};\n\nClient.prototype.changeSoapHeader = function(index, soapHeader, name, namespace, xmlns) {\n  if (!this.soapHeaders) {\n    this.soapHeaders = [];\n  }\n  if (typeof soapHeader === 'object') {\n    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);\n  }\n  this.soapHeaders[index] = soapHeader;\n};\n\nClient.prototype.getSoapHeaders = function() {\n  return this.soapHeaders;\n};\n\nClient.prototype.clearSoapHeaders = function() {\n  this.soapHeaders = null;\n};\n\nClient.prototype.addHttpHeader = function(name, value) {\n  if (!this.httpHeaders) {\n    this.httpHeaders = {};\n  }\n  this.httpHeaders[name] = value;\n};\n\nClient.prototype.getHttpHeaders = function() {\n  return this.httpHeaders;\n};\n\nClient.prototype.clearHttpHeaders = function() {\n  this.httpHeaders = {};\n};\n\n\nClient.prototype.addBodyAttribute = function(bodyAttribute, name, namespace, xmlns) {\n  if (!this.bodyAttributes) {\n    this.bodyAttributes = [];\n  }\n  if (typeof bodyAttribute === 'object') {\n    let composition = '';\n    Object.getOwnPropertyNames(bodyAttribute).forEach(function(prop, idx, array) {\n      composition += ' ' + prop + '=\"' + bodyAttribute[prop] + '\"';\n    });\n    bodyAttribute = composition;\n  }\n  if (bodyAttribute.substr(0, 1) !== ' ') bodyAttribute = ' ' + bodyAttribute;\n  this.bodyAttributes.push(bodyAttribute);\n};\n\nClient.prototype.getBodyAttributes = function() {\n  return this.bodyAttributes;\n};\n\nClient.prototype.clearBodyAttributes = function() {\n  this.bodyAttributes = null;\n};\n\nClient.prototype.setEndpoint = function(endpoint) {\n  this.endpoint = endpoint;\n  this._initializeServices(endpoint);\n};\n\nClient.prototype.describe = function() {\n  const types = this.wsdl.definitions.types;\n  return this.wsdl.describeServices();\n};\n\nClient.prototype.setSecurity = function(security) {\n  this.security = security;\n};\n\nClient.prototype.setSOAPAction = function(SOAPAction) {\n  this.SOAPAction = SOAPAction;\n};\n\nClient.prototype._initializeServices = function(endpoint) {\n  const definitions = this.wsdl.definitions,\n    services = definitions.services;\n  for (const name in services) {\n    this[name] = this._defineService(services[name], endpoint);\n  }\n};\n\nClient.prototype._initializeOptions = function(options) {\n  this.streamAllowed = options.stream;\n  this.normalizeNames = options.normalizeNames;\n  this.wsdl.options.attributesKey = options.attributesKey || 'attributes';\n  this.wsdl.options.envelopeKey = options.envelopeKey || 'soap';\n  this.wsdl.options.preserveWhitespace = !!options.preserveWhitespace;\n  if(options.ignoredNamespaces !== undefined) {\n    if(options.ignoredNamespaces.override !== undefined) {\n      if(options.ignoredNamespaces.override === true) {\n        if(options.ignoredNamespaces.namespaces !== undefined) {\n          this.wsdl.options.ignoredNamespaces = options.ignoredNamespaces.namespaces;\n        }\n      }\n    }\n  }\n  if(options.overrideRootElement !== undefined) {\n    this.wsdl.options.overrideRootElement = options.overrideRootElement;\n  }\n  this.wsdl.options.forceSoap12Headers = !!options.forceSoap12Headers;\n};\n\nClient.prototype._defineService = function(service, endpoint) {\n  const ports = service.ports,\n    def = {};\n  for (const name in ports) {\n    def[name] = this._definePort(ports[name], endpoint ? endpoint : ports[name].location);\n  }\n  return def;\n};\n\nClient.prototype._definePort = function(port, endpoint) {\n  const location = endpoint,\n    binding = port.binding,\n    methods = binding.methods,\n    def = {};\n  for (const name in methods) {\n    def[name] = this._defineMethod(methods[name], location);\n    const methodName = this.normalizeNames ? name.replace(nonIdentifierChars, '_') : name;\n    this[methodName] = def[name];\n  }\n  return def;\n};\n\nClient.prototype._defineMethod = function(method, location) {\n  const self = this;\n  let temp = null;\n  return function(args, options, extraHeaders): Observable<any> {\n    return self._invoke(method, args, location, options, extraHeaders);\n  };\n};\n\nClient.prototype._invoke = function(method, args, location, options, extraHeaders): Observable<any> {\n  let self = this,\n    name = method.$name,\n    input = method.input,\n    output = method.output,\n    style = method.style,\n    defs = this.wsdl.definitions,\n    envelopeKey = this.wsdl.options.envelopeKey,\n    ns = defs.$targetNamespace,\n    encoding = '',\n    message = '',\n    xml = null,\n    req = null,\n    soapAction = null,\n    alias = findPrefix(defs.xmlns, ns),\n    headers: any = {\n      \"Content-Type\": \"text/xml; charset=utf-8\"\n    },\n    xmlnsSoap = \"xmlns:\" + envelopeKey + \"=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"\";\n\n  if (this.wsdl.options.forceSoap12Headers) {\n    headers[\"Content-Type\"] = \"application/soap+xml; charset=utf-8\";\n    xmlnsSoap = \"xmlns:\" + envelopeKey + \"=\\\"http://www.w3.org/2003/05/soap-envelope\\\"\";\n  }\n\n  if (this.SOAPAction) {\n    soapAction = this.SOAPAction;\n  } else if (method.soapAction !== undefined && method.soapAction !== null) {\n    soapAction = method.soapAction;\n  } else {\n    soapAction = ((ns.lastIndexOf(\"/\") !== ns.length - 1) ? ns + \"/\" : ns) + name;\n  }\n\n  if (!this.wsdl.options.forceSoap12Headers) {\n    headers.SOAPAction = '\"' + soapAction + '\"';\n  }\n\n  options = options || {};\n\n  //Add extra headers\n  for (const header in this.httpHeaders ) { headers[header] = this.httpHeaders[header];  }\n  for (const attr in extraHeaders) { headers[attr] = extraHeaders[attr]; }\n\n  // Allow the security object to add headers\n  if (self.security && self.security.addHeaders)\n    self.security.addHeaders(headers);\n  if (self.security && self.security.addOptions)\n    self.security.addOptions(options);\n\n  if ((style === 'rpc')&& ( ( input.parts || input.name===\"element\" ) || args === null) ) {\n    assert.ok(!style || style === 'rpc', 'invalid message definition for document style binding');\n    message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==\"element\" ));\n    (method.inputSoap === 'encoded') && (encoding = 'soap:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\" ');\n  } else {\n    assert.ok(!style || style === 'document', 'invalid message definition for rpc style binding');\n    // pass `input.$lookupType` if `input.$type` could not be found\n    message = self.wsdl.objectToDocumentXML(input.$name, args, input.targetNSAlias, input.targetNamespace, (input.$type || input.$lookupType));\n  }\n  xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" +\n    \"<\" + envelopeKey + \":Envelope \" +\n    xmlnsSoap + \" \" +\n    \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" +\n    encoding +\n    this.wsdl.xmlnsInEnvelope + '>' +\n    ((self.soapHeaders || self.security) ?\n      (\n        \"<\" + envelopeKey + \":Header>\" +\n        (self.soapHeaders ? self.soapHeaders.join(\"\\n\") : \"\") +\n        (self.security && !self.security.postProcess ? self.security.toXML() : \"\") +\n        \"</\" + envelopeKey + \":Header>\"\n      )\n      :\n        ''\n      ) +\n    \"<\" + envelopeKey + \":Body\" +\n    (self.bodyAttributes ? self.bodyAttributes.join(' ') : '') +\n    (self.security && self.security.postProcess ? ' Id=\"_0\"' : '') +\n    \">\" +\n    message +\n    \"</\" + envelopeKey + \":Body>\" +\n    \"</\" + envelopeKey + \":Envelope>\";\n\n  if(self.security && self.security.postProcess){\n    xml = self.security.postProcess(xml, envelopeKey);\n  }\n\n  if(options && options.postProcess){\n    xml = options.postProcess(xml);\n  }\n\n  self.lastMessage = message;\n  self.lastRequest = xml;\n  self.lastEndpoint = location;\n\n  const eid = options.exchangeId || uuid4();\n\n  // self.emit('message', message, eid);\n  // self.emit('request', xml, eid);\n\n  const tryJSONparse = function(body) {\n    try {\n      return JSON.parse(body);\n    }\n    catch(err) {\n      return undefined;\n    }\n  };\n\n  //console.log('url:', location)\n  \n  return (<HttpClient>self.httpClient).post(location, xml, {\n    headers: headers,\n    responseType: 'text', observe: 'response' }).pipe(\n    map((response: HttpResponse<any>) => {\n      self.lastResponse = response.body;\n      self.lastResponseHeaders = response && response.headers;\n      // self.lastElapsedTime = response && response.elapsedTime;\n      // self.emit('response', response.body, response, eid);\n      //console.log('responce body before sync', response.body);\n      return parseSync(response.body, response)\n    })\n  );\n\n  function parseSync(body, response: HttpResponse<any>) {\n    let obj;\n    try {\n      obj = self.wsdl.xmlToObject(body);\n      //console.log('parsed body',obj);\n    } catch (error) {\n      //  When the output element cannot be looked up in the wsdl and the body is JSON\n      //  instead of sending the error, we pass the body in the response.\n      if(!output || !output.$lookupTypes) {\n        // debug('Response element is not present. Unable to convert response xml to json.');\n        //  If the response is JSON then return it as-is.\n        const json = _.isObject(body) ? body : tryJSONparse(body);\n        if (json) {\n          return { err: null, response, responseBody: json, header: undefined, xml };\n        }\n      }\n      error.response = response;\n      error.body = body;\n      // self.emit('soapError', error, eid);\n      throw error;\n    }\n    return finish(obj, body, response);\n  }\n\n  function finish(obj, responseBody, response) {\n    let result = null;\n\n    if (!output){\n      // one-way, no output expected\n      return { err: null, response: null, responseBody, header: obj.Header, xml };\n    }\n\n    // If it's not HTML and Soap Body is empty\n    if (!obj.html && !obj.Body) {\n      return  { err: null, obj, responseBody, header: obj.Header, xml }; \n    }\n\n    if( typeof obj.Body !== 'object' ) {\n      const error: any = new Error('Cannot parse response');\n      error.response = response;\n      error.body = responseBody;\n      return { err: error, obj, responseBody, header: undefined, xml }; \n    }\n\n    result = obj.Body[output.$name];\n    // RPC/literal response body may contain elements with added suffixes I.E.\n    // 'Response', or 'Output', or 'Out'\n    // This doesn't necessarily equal the ouput message name. See WSDL 1.1 Section 2.4.5\n    if(!result){\n      result = obj.Body[output.$name.replace(/(?:Out(?:put)?|Response)$/, '')];\n    }\n    if (!result) {\n      ['Response', 'Out', 'Output'].forEach(function (term) {\n        if (obj.Body.hasOwnProperty(name + term)) {\n          return result = obj.Body[name + term];\n        }\n      });\n    }\n    \n    return { err: null, result, responseBody, header: obj.Header, xml }; \n  }\n};\n\nClient.prototype.call = function (method: string, body: any, options?: any, extraHeaders?: any): Observable<any> {\n  if (!this[method]) {\n    return throwError(`Method ${method} not found`);\n  }\n\n  return (<Function>this[method]).call(this, body, options, extraHeaders);\n}\n","/*\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\n * MIT Licensed\n */\n\nimport * as wsdl from './wsdl';\nimport { security } from './security/security';\nimport { Client } from './client';\n\nexport { passwordDigest } from './utils'\nexport const WSDL = wsdl.WSDL;\n\nconst cache = {}; // TODO some caching?\n\nconst getFromCache = async (url, options) => {\n  // console.log('Getting from cache', url);\n  // console.log('Cache', cache)\n  if (cache[url]) {\n    // console.log('Found in cache', url);\n    return cache[url];\n  } else {\n    return wsdl.open_wsdl(url, options).then(wsdl => {\n      cache[url] = wsdl;\n      return wsdl;\n    })\n  }\n};\n\n\nasync function _requestWSDL(url, options) {\n  if (options.disableCache === true) {\n    return wsdl.open_wsdl(url, options);\n  } else {\n    return getFromCache(url, options);\n  }\n\n}\n\nexport async function createClient(url, options, endpoint): Promise<any> {\n  if (typeof options === 'undefined') {\n    options = {};\n  }\n  // console.log(\"createClient\", options)\n  endpoint = options.endpoint || endpoint;\n  \n  const wsdl = await _requestWSDL(url, options);\n  const client = new Client(wsdl, endpoint, options);\n  return client;\n}\n\nexport const BasicAuthSecurity = security.BasicAuthSecurity;\nexport const NTLMSecurity = security.NTLMSecurity;\nexport const WSSecurity = security.WSSecurity;\n// export const WSSecurityCert = security.WSSecurityCert;\nexport const BearerSecurity = security.BearerSecurity;\n// export const ClientSSLSecurity = security.ClientSSLSecurity;\n// export const ClientSSLSecurityPFX = security.ClientSSLSecurityPFX;\n","import { Injectable } from '@angular/core';\nimport { createClient } from './soap/soap';\nimport { HttpClient } from '@angular/common/http';\nimport { Client } from './soap/interfaces';\n\nexport {\n  Client,\n  WSDL,\n  ISoapMethod,\n  ISoapMethodResponse,\n  BasicAuthSecurity,\n  BearerSecurity,\n  // WSSecurityCert,\n  WSSecurity,\n  NTLMSecurity\n} from './soap/interfaces';\n\nexport { security } from './soap/security/security'\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class NgxSoapService {\n\n  constructor(private http: HttpClient) { }\n\n  createClient(wsdlUrl: string, options: any = {}, endpoint?: string): Promise<Client> {\n    options.httpClient = this.http;\n    return createClient(wsdlUrl, options, endpoint) ;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n  imports: [\n    HttpClientModule\n  ],\n  exports: []\n})\nexport class NgxSoapModule { }\n"]}